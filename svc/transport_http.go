// Code generated by truss. DO NOT EDIT.
// Rerunning truss will overwrite this file.
// Version: 5f7d5bf015
// Version Date: 2021-11-26T09:27:01Z

package svc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"github.com/gogo/protobuf/jsonpb"
	"github.com/gogo/protobuf/proto"

	"context"

	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/gorilla/mux"
	"github.com/pkg/errors"

	// This service
	pb "github.com/mises-id/mises-swapsvc/proto"
)

const contentType = "application/json; charset=utf-8"

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = pb.NewSwapsvcClient
	_ = io.Copy
	_ = errors.Wrap
)

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(endpoints Endpoints, responseEncoder httptransport.EncodeResponseFunc, options ...httptransport.ServerOption) http.Handler {
	if responseEncoder == nil {
		responseEncoder = EncodeHTTPGenericResponse
	}
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(headersToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerAfter(httptransport.SetContentType(contentType)),
	}
	serverOptions = append(serverOptions, options...)
	m := mux.NewRouter()

	m.Methods("GET").Path("/swap_order/sync/").Handler(httptransport.NewServer(
		endpoints.SyncSwapOrderEndpoint,
		DecodeHTTPSyncSwapOrderZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap_order/sync").Handler(httptransport.NewServer(
		endpoints.SyncSwapOrderEndpoint,
		DecodeHTTPSyncSwapOrderOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap_order/page/").Handler(httptransport.NewServer(
		endpoints.SwapOrderPageEndpoint,
		DecodeHTTPSwapOrderPageZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap_order/page").Handler(httptransport.NewServer(
		endpoints.SwapOrderPageEndpoint,
		DecodeHTTPSwapOrderPageOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap_order/find/").Handler(httptransport.NewServer(
		endpoints.FindSwapOrderEndpoint,
		DecodeHTTPFindSwapOrderZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap_order/find").Handler(httptransport.NewServer(
		endpoints.FindSwapOrderEndpoint,
		DecodeHTTPFindSwapOrderOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap_token/list/").Handler(httptransport.NewServer(
		endpoints.ListSwapTokenEndpoint,
		DecodeHTTPListSwapTokenZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap_token/list").Handler(httptransport.NewServer(
		endpoints.ListSwapTokenEndpoint,
		DecodeHTTPListSwapTokenOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap/approve/allowance/").Handler(httptransport.NewServer(
		endpoints.GetSwapApproveAllowanceEndpoint,
		DecodeHTTPGetSwapApproveAllowanceZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap/approve/allowance").Handler(httptransport.NewServer(
		endpoints.GetSwapApproveAllowanceEndpoint,
		DecodeHTTPGetSwapApproveAllowanceOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap/approve/transaction/").Handler(httptransport.NewServer(
		endpoints.ApproveSwapTransactionEndpoint,
		DecodeHTTPApproveSwapTransactionZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap/approve/transaction").Handler(httptransport.NewServer(
		endpoints.ApproveSwapTransactionEndpoint,
		DecodeHTTPApproveSwapTransactionOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap/trade/").Handler(httptransport.NewServer(
		endpoints.SwapTradeEndpoint,
		DecodeHTTPSwapTradeZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap/trade").Handler(httptransport.NewServer(
		endpoints.SwapTradeEndpoint,
		DecodeHTTPSwapTradeOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/swap/quote/").Handler(httptransport.NewServer(
		endpoints.SwapQuoteEndpoint,
		DecodeHTTPSwapQuoteZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/swap/quote").Handler(httptransport.NewServer(
		endpoints.SwapQuoteEndpoint,
		DecodeHTTPSwapQuoteOneRequest,
		responseEncoder,
		serverOptions...,
	))

	m.Methods("GET").Path("/test/").Handler(httptransport.NewServer(
		endpoints.TestEndpoint,
		DecodeHTTPTestZeroRequest,
		responseEncoder,
		serverOptions...,
	))
	m.Methods("GET").Path("/test").Handler(httptransport.NewServer(
		endpoints.TestEndpoint,
		DecodeHTTPTestOneRequest,
		responseEncoder,
		serverOptions...,
	))
	return m
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	body, _ := json.Marshal(errorWrapper{Error: err.Error()})
	if marshaler, ok := err.(json.Marshaler); ok {
		if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
			body = jsonBody
		}
	}
	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}
	code := http.StatusInternalServerError
	if sc, ok := err.(httptransport.StatusCoder); ok {
		code = sc.StatusCode()
	}
	w.WriteHeader(code)
	w.Write(body)
}

type errorWrapper struct {
	Error string `json:"error"`
}

// httpError satisfies the Headerer and StatusCoder interfaces in
// package github.com/go-kit/kit/transport/http.
type httpError struct {
	error
	statusCode int
	headers    map[string][]string
}

func (h httpError) StatusCode() int {
	return h.statusCode
}

func (h httpError) Headers() http.Header {
	return h.headers
}

// Server Decode

// DecodeHTTPSyncSwapOrderZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded syncswaporder request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSyncSwapOrderZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SyncSwapOrderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPSyncSwapOrderOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded syncswaporder request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSyncSwapOrderOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SyncSwapOrderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPSwapOrderPageZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded swaporderpage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSwapOrderPageZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SwapOrderPageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDSwapOrderPageStrArr, ok := queryParams["chainID"]; ok {
		ChainIDSwapOrderPageStr := ChainIDSwapOrderPageStrArr[0]
		ChainIDSwapOrderPage, err := strconv.ParseUint(ChainIDSwapOrderPageStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDSwapOrderPage from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDSwapOrderPage
	}

	if FromAddressSwapOrderPageStrArr, ok := queryParams["from_address"]; ok {
		FromAddressSwapOrderPageStr := FromAddressSwapOrderPageStrArr[0]
		FromAddressSwapOrderPage := FromAddressSwapOrderPageStr
		req.FromAddress = FromAddressSwapOrderPage
	}

	if PaginatorSwapOrderPageStrArr, ok := queryParams["paginator"]; ok {
		PaginatorSwapOrderPageStr := PaginatorSwapOrderPageStrArr[0]

		err = json.Unmarshal([]byte(PaginatorSwapOrderPageStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorSwapOrderPage from %v", PaginatorSwapOrderPageStr)
		}

	}

	return &req, err
}

// DecodeHTTPSwapOrderPageOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded swaporderpage request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSwapOrderPageOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SwapOrderPageRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDSwapOrderPageStrArr, ok := queryParams["chainID"]; ok {
		ChainIDSwapOrderPageStr := ChainIDSwapOrderPageStrArr[0]
		ChainIDSwapOrderPage, err := strconv.ParseUint(ChainIDSwapOrderPageStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDSwapOrderPage from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDSwapOrderPage
	}

	if FromAddressSwapOrderPageStrArr, ok := queryParams["from_address"]; ok {
		FromAddressSwapOrderPageStr := FromAddressSwapOrderPageStrArr[0]
		FromAddressSwapOrderPage := FromAddressSwapOrderPageStr
		req.FromAddress = FromAddressSwapOrderPage
	}

	if PaginatorSwapOrderPageStrArr, ok := queryParams["paginator"]; ok {
		PaginatorSwapOrderPageStr := PaginatorSwapOrderPageStrArr[0]

		err = json.Unmarshal([]byte(PaginatorSwapOrderPageStr), req.Paginator)
		if err != nil {
			return nil, errors.Wrapf(err, "couldn't decode PaginatorSwapOrderPage from %v", PaginatorSwapOrderPageStr)
		}

	}

	return &req, err
}

// DecodeHTTPFindSwapOrderZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded findswaporder request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindSwapOrderZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindSwapOrderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDFindSwapOrderStrArr, ok := queryParams["chainID"]; ok {
		ChainIDFindSwapOrderStr := ChainIDFindSwapOrderStrArr[0]
		ChainIDFindSwapOrder, err := strconv.ParseUint(ChainIDFindSwapOrderStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDFindSwapOrder from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDFindSwapOrder
	}

	if TxHashFindSwapOrderStrArr, ok := queryParams["tx_hash"]; ok {
		TxHashFindSwapOrderStr := TxHashFindSwapOrderStrArr[0]
		TxHashFindSwapOrder := TxHashFindSwapOrderStr
		req.TxHash = TxHashFindSwapOrder
	}

	if FromAddressFindSwapOrderStrArr, ok := queryParams["from_address"]; ok {
		FromAddressFindSwapOrderStr := FromAddressFindSwapOrderStrArr[0]
		FromAddressFindSwapOrder := FromAddressFindSwapOrderStr
		req.FromAddress = FromAddressFindSwapOrder
	}

	return &req, err
}

// DecodeHTTPFindSwapOrderOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded findswaporder request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPFindSwapOrderOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.FindSwapOrderRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDFindSwapOrderStrArr, ok := queryParams["chainID"]; ok {
		ChainIDFindSwapOrderStr := ChainIDFindSwapOrderStrArr[0]
		ChainIDFindSwapOrder, err := strconv.ParseUint(ChainIDFindSwapOrderStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDFindSwapOrder from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDFindSwapOrder
	}

	if TxHashFindSwapOrderStrArr, ok := queryParams["tx_hash"]; ok {
		TxHashFindSwapOrderStr := TxHashFindSwapOrderStrArr[0]
		TxHashFindSwapOrder := TxHashFindSwapOrderStr
		req.TxHash = TxHashFindSwapOrder
	}

	if FromAddressFindSwapOrderStrArr, ok := queryParams["from_address"]; ok {
		FromAddressFindSwapOrderStr := FromAddressFindSwapOrderStrArr[0]
		FromAddressFindSwapOrder := FromAddressFindSwapOrderStr
		req.FromAddress = FromAddressFindSwapOrder
	}

	return &req, err
}

// DecodeHTTPListSwapTokenZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listswaptoken request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListSwapTokenZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListSwapTokenRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDListSwapTokenStrArr, ok := queryParams["chainID"]; ok {
		ChainIDListSwapTokenStr := ChainIDListSwapTokenStrArr[0]
		ChainIDListSwapToken, err := strconv.ParseUint(ChainIDListSwapTokenStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDListSwapToken from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDListSwapToken
	}

	if TokenAddressListSwapTokenStrArr, ok := queryParams["token_address"]; ok {
		TokenAddressListSwapTokenStr := TokenAddressListSwapTokenStrArr[0]
		TokenAddressListSwapToken := TokenAddressListSwapTokenStr
		req.TokenAddress = TokenAddressListSwapToken
	}

	return &req, err
}

// DecodeHTTPListSwapTokenOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded listswaptoken request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListSwapTokenOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ListSwapTokenRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDListSwapTokenStrArr, ok := queryParams["chainID"]; ok {
		ChainIDListSwapTokenStr := ChainIDListSwapTokenStrArr[0]
		ChainIDListSwapToken, err := strconv.ParseUint(ChainIDListSwapTokenStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDListSwapToken from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDListSwapToken
	}

	if TokenAddressListSwapTokenStrArr, ok := queryParams["token_address"]; ok {
		TokenAddressListSwapTokenStr := TokenAddressListSwapTokenStrArr[0]
		TokenAddressListSwapToken := TokenAddressListSwapTokenStr
		req.TokenAddress = TokenAddressListSwapToken
	}

	return &req, err
}

// DecodeHTTPGetSwapApproveAllowanceZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getswapapproveallowance request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetSwapApproveAllowanceZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetSwapApproveAllowanceRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDGetSwapApproveAllowanceStrArr, ok := queryParams["chainID"]; ok {
		ChainIDGetSwapApproveAllowanceStr := ChainIDGetSwapApproveAllowanceStrArr[0]
		ChainIDGetSwapApproveAllowance, err := strconv.ParseUint(ChainIDGetSwapApproveAllowanceStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDGetSwapApproveAllowance from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDGetSwapApproveAllowance
	}

	if TokenAddressGetSwapApproveAllowanceStrArr, ok := queryParams["token_address"]; ok {
		TokenAddressGetSwapApproveAllowanceStr := TokenAddressGetSwapApproveAllowanceStrArr[0]
		TokenAddressGetSwapApproveAllowance := TokenAddressGetSwapApproveAllowanceStr
		req.TokenAddress = TokenAddressGetSwapApproveAllowance
	}

	if WalletAddressGetSwapApproveAllowanceStrArr, ok := queryParams["wallet_address"]; ok {
		WalletAddressGetSwapApproveAllowanceStr := WalletAddressGetSwapApproveAllowanceStrArr[0]
		WalletAddressGetSwapApproveAllowance := WalletAddressGetSwapApproveAllowanceStr
		req.WalletAddress = WalletAddressGetSwapApproveAllowance
	}

	if AggregatorAddressGetSwapApproveAllowanceStrArr, ok := queryParams["aggregator_address"]; ok {
		AggregatorAddressGetSwapApproveAllowanceStr := AggregatorAddressGetSwapApproveAllowanceStrArr[0]
		AggregatorAddressGetSwapApproveAllowance := AggregatorAddressGetSwapApproveAllowanceStr
		req.AggregatorAddress = AggregatorAddressGetSwapApproveAllowance
	}

	return &req, err
}

// DecodeHTTPGetSwapApproveAllowanceOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getswapapproveallowance request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetSwapApproveAllowanceOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.GetSwapApproveAllowanceRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDGetSwapApproveAllowanceStrArr, ok := queryParams["chainID"]; ok {
		ChainIDGetSwapApproveAllowanceStr := ChainIDGetSwapApproveAllowanceStrArr[0]
		ChainIDGetSwapApproveAllowance, err := strconv.ParseUint(ChainIDGetSwapApproveAllowanceStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDGetSwapApproveAllowance from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDGetSwapApproveAllowance
	}

	if TokenAddressGetSwapApproveAllowanceStrArr, ok := queryParams["token_address"]; ok {
		TokenAddressGetSwapApproveAllowanceStr := TokenAddressGetSwapApproveAllowanceStrArr[0]
		TokenAddressGetSwapApproveAllowance := TokenAddressGetSwapApproveAllowanceStr
		req.TokenAddress = TokenAddressGetSwapApproveAllowance
	}

	if WalletAddressGetSwapApproveAllowanceStrArr, ok := queryParams["wallet_address"]; ok {
		WalletAddressGetSwapApproveAllowanceStr := WalletAddressGetSwapApproveAllowanceStrArr[0]
		WalletAddressGetSwapApproveAllowance := WalletAddressGetSwapApproveAllowanceStr
		req.WalletAddress = WalletAddressGetSwapApproveAllowance
	}

	if AggregatorAddressGetSwapApproveAllowanceStrArr, ok := queryParams["aggregator_address"]; ok {
		AggregatorAddressGetSwapApproveAllowanceStr := AggregatorAddressGetSwapApproveAllowanceStrArr[0]
		AggregatorAddressGetSwapApproveAllowance := AggregatorAddressGetSwapApproveAllowanceStr
		req.AggregatorAddress = AggregatorAddressGetSwapApproveAllowance
	}

	return &req, err
}

// DecodeHTTPApproveSwapTransactionZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded approveswaptransaction request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPApproveSwapTransactionZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ApproveSwapTransactionRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDApproveSwapTransactionStrArr, ok := queryParams["chainID"]; ok {
		ChainIDApproveSwapTransactionStr := ChainIDApproveSwapTransactionStrArr[0]
		ChainIDApproveSwapTransaction, err := strconv.ParseUint(ChainIDApproveSwapTransactionStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDApproveSwapTransaction from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDApproveSwapTransaction
	}

	if TokenAddressApproveSwapTransactionStrArr, ok := queryParams["token_address"]; ok {
		TokenAddressApproveSwapTransactionStr := TokenAddressApproveSwapTransactionStrArr[0]
		TokenAddressApproveSwapTransaction := TokenAddressApproveSwapTransactionStr
		req.TokenAddress = TokenAddressApproveSwapTransaction
	}

	if AmountApproveSwapTransactionStrArr, ok := queryParams["amount"]; ok {
		AmountApproveSwapTransactionStr := AmountApproveSwapTransactionStrArr[0]
		AmountApproveSwapTransaction := AmountApproveSwapTransactionStr
		req.Amount = AmountApproveSwapTransaction
	}

	if AggregatorAddressApproveSwapTransactionStrArr, ok := queryParams["aggregator_address"]; ok {
		AggregatorAddressApproveSwapTransactionStr := AggregatorAddressApproveSwapTransactionStrArr[0]
		AggregatorAddressApproveSwapTransaction := AggregatorAddressApproveSwapTransactionStr
		req.AggregatorAddress = AggregatorAddressApproveSwapTransaction
	}

	return &req, err
}

// DecodeHTTPApproveSwapTransactionOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded approveswaptransaction request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPApproveSwapTransactionOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.ApproveSwapTransactionRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDApproveSwapTransactionStrArr, ok := queryParams["chainID"]; ok {
		ChainIDApproveSwapTransactionStr := ChainIDApproveSwapTransactionStrArr[0]
		ChainIDApproveSwapTransaction, err := strconv.ParseUint(ChainIDApproveSwapTransactionStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDApproveSwapTransaction from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDApproveSwapTransaction
	}

	if TokenAddressApproveSwapTransactionStrArr, ok := queryParams["token_address"]; ok {
		TokenAddressApproveSwapTransactionStr := TokenAddressApproveSwapTransactionStrArr[0]
		TokenAddressApproveSwapTransaction := TokenAddressApproveSwapTransactionStr
		req.TokenAddress = TokenAddressApproveSwapTransaction
	}

	if AmountApproveSwapTransactionStrArr, ok := queryParams["amount"]; ok {
		AmountApproveSwapTransactionStr := AmountApproveSwapTransactionStrArr[0]
		AmountApproveSwapTransaction := AmountApproveSwapTransactionStr
		req.Amount = AmountApproveSwapTransaction
	}

	if AggregatorAddressApproveSwapTransactionStrArr, ok := queryParams["aggregator_address"]; ok {
		AggregatorAddressApproveSwapTransactionStr := AggregatorAddressApproveSwapTransactionStrArr[0]
		AggregatorAddressApproveSwapTransaction := AggregatorAddressApproveSwapTransactionStr
		req.AggregatorAddress = AggregatorAddressApproveSwapTransaction
	}

	return &req, err
}

// DecodeHTTPSwapTradeZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded swaptrade request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSwapTradeZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SwapTradeRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDSwapTradeStrArr, ok := queryParams["chainID"]; ok {
		ChainIDSwapTradeStr := ChainIDSwapTradeStrArr[0]
		ChainIDSwapTrade, err := strconv.ParseUint(ChainIDSwapTradeStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDSwapTrade from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDSwapTrade
	}

	if AmountSwapTradeStrArr, ok := queryParams["amount"]; ok {
		AmountSwapTradeStr := AmountSwapTradeStrArr[0]
		AmountSwapTrade := AmountSwapTradeStr
		req.Amount = AmountSwapTrade
	}

	if FromTokenAddressSwapTradeStrArr, ok := queryParams["from_token_address"]; ok {
		FromTokenAddressSwapTradeStr := FromTokenAddressSwapTradeStrArr[0]
		FromTokenAddressSwapTrade := FromTokenAddressSwapTradeStr
		req.FromTokenAddress = FromTokenAddressSwapTrade
	}

	if ToTokenAddressSwapTradeStrArr, ok := queryParams["to_token_address"]; ok {
		ToTokenAddressSwapTradeStr := ToTokenAddressSwapTradeStrArr[0]
		ToTokenAddressSwapTrade := ToTokenAddressSwapTradeStr
		req.ToTokenAddress = ToTokenAddressSwapTrade
	}

	if SlippageSwapTradeStrArr, ok := queryParams["slippage"]; ok {
		SlippageSwapTradeStr := SlippageSwapTradeStrArr[0]
		SlippageSwapTrade, err := strconv.ParseFloat(SlippageSwapTradeStr, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting SlippageSwapTrade from query, queryParams: %v", queryParams))
		}
		req.Slippage = float32(SlippageSwapTrade)
	}

	if FromAddressSwapTradeStrArr, ok := queryParams["from_address"]; ok {
		FromAddressSwapTradeStr := FromAddressSwapTradeStrArr[0]
		FromAddressSwapTrade := FromAddressSwapTradeStr
		req.FromAddress = FromAddressSwapTrade
	}

	if DestReceiverSwapTradeStrArr, ok := queryParams["dest_receiver"]; ok {
		DestReceiverSwapTradeStr := DestReceiverSwapTradeStrArr[0]
		DestReceiverSwapTrade := DestReceiverSwapTradeStr
		req.DestReceiver = DestReceiverSwapTrade
	}

	if AggregatorAddressSwapTradeStrArr, ok := queryParams["aggregator_address"]; ok {
		AggregatorAddressSwapTradeStr := AggregatorAddressSwapTradeStrArr[0]
		AggregatorAddressSwapTrade := AggregatorAddressSwapTradeStr
		req.AggregatorAddress = AggregatorAddressSwapTrade
	}

	return &req, err
}

// DecodeHTTPSwapTradeOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded swaptrade request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSwapTradeOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SwapTradeRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDSwapTradeStrArr, ok := queryParams["chainID"]; ok {
		ChainIDSwapTradeStr := ChainIDSwapTradeStrArr[0]
		ChainIDSwapTrade, err := strconv.ParseUint(ChainIDSwapTradeStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDSwapTrade from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDSwapTrade
	}

	if AmountSwapTradeStrArr, ok := queryParams["amount"]; ok {
		AmountSwapTradeStr := AmountSwapTradeStrArr[0]
		AmountSwapTrade := AmountSwapTradeStr
		req.Amount = AmountSwapTrade
	}

	if FromTokenAddressSwapTradeStrArr, ok := queryParams["from_token_address"]; ok {
		FromTokenAddressSwapTradeStr := FromTokenAddressSwapTradeStrArr[0]
		FromTokenAddressSwapTrade := FromTokenAddressSwapTradeStr
		req.FromTokenAddress = FromTokenAddressSwapTrade
	}

	if ToTokenAddressSwapTradeStrArr, ok := queryParams["to_token_address"]; ok {
		ToTokenAddressSwapTradeStr := ToTokenAddressSwapTradeStrArr[0]
		ToTokenAddressSwapTrade := ToTokenAddressSwapTradeStr
		req.ToTokenAddress = ToTokenAddressSwapTrade
	}

	if SlippageSwapTradeStrArr, ok := queryParams["slippage"]; ok {
		SlippageSwapTradeStr := SlippageSwapTradeStrArr[0]
		SlippageSwapTrade, err := strconv.ParseFloat(SlippageSwapTradeStr, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting SlippageSwapTrade from query, queryParams: %v", queryParams))
		}
		req.Slippage = float32(SlippageSwapTrade)
	}

	if FromAddressSwapTradeStrArr, ok := queryParams["from_address"]; ok {
		FromAddressSwapTradeStr := FromAddressSwapTradeStrArr[0]
		FromAddressSwapTrade := FromAddressSwapTradeStr
		req.FromAddress = FromAddressSwapTrade
	}

	if DestReceiverSwapTradeStrArr, ok := queryParams["dest_receiver"]; ok {
		DestReceiverSwapTradeStr := DestReceiverSwapTradeStrArr[0]
		DestReceiverSwapTrade := DestReceiverSwapTradeStr
		req.DestReceiver = DestReceiverSwapTrade
	}

	if AggregatorAddressSwapTradeStrArr, ok := queryParams["aggregator_address"]; ok {
		AggregatorAddressSwapTradeStr := AggregatorAddressSwapTradeStrArr[0]
		AggregatorAddressSwapTrade := AggregatorAddressSwapTradeStr
		req.AggregatorAddress = AggregatorAddressSwapTrade
	}

	return &req, err
}

// DecodeHTTPSwapQuoteZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded swapquote request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSwapQuoteZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SwapQuoteRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDSwapQuoteStrArr, ok := queryParams["chainID"]; ok {
		ChainIDSwapQuoteStr := ChainIDSwapQuoteStrArr[0]
		ChainIDSwapQuote, err := strconv.ParseUint(ChainIDSwapQuoteStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDSwapQuote from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDSwapQuote
	}

	if AmountSwapQuoteStrArr, ok := queryParams["amount"]; ok {
		AmountSwapQuoteStr := AmountSwapQuoteStrArr[0]
		AmountSwapQuote := AmountSwapQuoteStr
		req.Amount = AmountSwapQuote
	}

	if FromTokenAddressSwapQuoteStrArr, ok := queryParams["from_token_address"]; ok {
		FromTokenAddressSwapQuoteStr := FromTokenAddressSwapQuoteStrArr[0]
		FromTokenAddressSwapQuote := FromTokenAddressSwapQuoteStr
		req.FromTokenAddress = FromTokenAddressSwapQuote
	}

	if ToTokenAddressSwapQuoteStrArr, ok := queryParams["to_token_address"]; ok {
		ToTokenAddressSwapQuoteStr := ToTokenAddressSwapQuoteStrArr[0]
		ToTokenAddressSwapQuote := ToTokenAddressSwapQuoteStr
		req.ToTokenAddress = ToTokenAddressSwapQuote
	}

	return &req, err
}

// DecodeHTTPSwapQuoteOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded swapquote request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSwapQuoteOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.SwapQuoteRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if ChainIDSwapQuoteStrArr, ok := queryParams["chainID"]; ok {
		ChainIDSwapQuoteStr := ChainIDSwapQuoteStrArr[0]
		ChainIDSwapQuote, err := strconv.ParseUint(ChainIDSwapQuoteStr, 10, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting ChainIDSwapQuote from query, queryParams: %v", queryParams))
		}
		req.ChainID = ChainIDSwapQuote
	}

	if AmountSwapQuoteStrArr, ok := queryParams["amount"]; ok {
		AmountSwapQuoteStr := AmountSwapQuoteStrArr[0]
		AmountSwapQuote := AmountSwapQuoteStr
		req.Amount = AmountSwapQuote
	}

	if FromTokenAddressSwapQuoteStrArr, ok := queryParams["from_token_address"]; ok {
		FromTokenAddressSwapQuoteStr := FromTokenAddressSwapQuoteStrArr[0]
		FromTokenAddressSwapQuote := FromTokenAddressSwapQuoteStr
		req.FromTokenAddress = FromTokenAddressSwapQuote
	}

	if ToTokenAddressSwapQuoteStrArr, ok := queryParams["to_token_address"]; ok {
		ToTokenAddressSwapQuoteStr := ToTokenAddressSwapQuoteStrArr[0]
		ToTokenAddressSwapQuote := ToTokenAddressSwapQuoteStr
		req.ToTokenAddress = ToTokenAddressSwapQuote
	}

	return &req, err
}

// DecodeHTTPTestZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded test request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTestZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TestRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if TypeTestStrArr, ok := queryParams["type"]; ok {
		TypeTestStr := TypeTestStrArr[0]
		TypeTest := TypeTestStr
		req.Type = TypeTest
	}

	return &req, err
}

// DecodeHTTPTestOneRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded test request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPTestOneRequest(_ context.Context, r *http.Request) (interface{}, error) {
	defer r.Body.Close()
	var req pb.TestRequest
	buf, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot read body of http request")
	}
	if len(buf) > 0 {
		// AllowUnknownFields stops the unmarshaler from failing if the JSON contains unknown fields.
		unmarshaller := jsonpb.Unmarshaler{
			AllowUnknownFields: true,
		}
		if err = unmarshaller.Unmarshal(bytes.NewBuffer(buf), &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, httpError{errors.Wrapf(err, "request body '%s': cannot parse non-json request body", buf),
				http.StatusBadRequest,
				nil,
			}
		}
	}

	pathParams := encodePathParams(mux.Vars(r))
	_ = pathParams

	queryParams := r.URL.Query()
	_ = queryParams

	if TypeTestStrArr, ok := queryParams["type"]; ok {
		TypeTestStr := TypeTestStrArr[0]
		TypeTest := TypeTestStr
		req.Type = TypeTest
	}

	return &req, err
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	marshaller := jsonpb.Marshaler{
		EmitDefaults: false,
		OrigName:     true,
	}

	return marshaller.Marshal(w, response.(proto.Message))
}

// Helper functions

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "request-url", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}

// encodePathParams encodes `mux.Vars()` with dot notations into JSON objects
// to be unmarshaled into non-basetype fields.
// e.g. {"book.name": "books/1"} -> {"book": {"name": "books/1"}}
func encodePathParams(vars map[string]string) map[string]string {
	var recur func(path, value string, data map[string]interface{})
	recur = func(path, value string, data map[string]interface{}) {
		parts := strings.SplitN(path, ".", 2)
		key := parts[0]
		if len(parts) == 1 {
			data[key] = value
		} else {
			if _, ok := data[key]; !ok {
				data[key] = make(map[string]interface{})
			}
			recur(parts[1], value, data[key].(map[string]interface{}))
		}
	}

	data := make(map[string]interface{})
	for key, val := range vars {
		recur(key, val, data)
	}

	ret := make(map[string]string)
	for key, val := range data {
		switch val := val.(type) {
		case string:
			ret[key] = val
		case map[string]interface{}:
			m, _ := json.Marshal(val)
			ret[key] = string(m)
		}
	}
	return ret
}
