// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: swapsvc.proto

// The package name determines the name of the directories that truss creates
// for `package echo;` truss will create the directory "echo-service".

package swapsvc

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/metaverse/truss/deftree/googlethirdparty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PageQuick struct {
	Limit  uint64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	NextId string `protobuf:"bytes,2,opt,name=next_id,json=nextId,proto3" json:"next_id,omitempty"`
	Total  uint64 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *PageQuick) Reset()         { *m = PageQuick{} }
func (m *PageQuick) String() string { return proto.CompactTextString(m) }
func (*PageQuick) ProtoMessage()    {}
func (*PageQuick) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{0}
}
func (m *PageQuick) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageQuick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PageQuick.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PageQuick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageQuick.Merge(m, src)
}
func (m *PageQuick) XXX_Size() int {
	return m.Size()
}
func (m *PageQuick) XXX_DiscardUnknown() {
	xxx_messageInfo_PageQuick.DiscardUnknown(m)
}

var xxx_messageInfo_PageQuick proto.InternalMessageInfo

func (m *PageQuick) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PageQuick) GetNextId() string {
	if m != nil {
		return m.NextId
	}
	return ""
}

func (m *PageQuick) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type Page struct {
	TotalRecords uint64 `protobuf:"varint,1,opt,name=total_records,json=totalRecords,proto3" json:"total_records,omitempty"`
	PageSize     uint64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageNum      uint64 `protobuf:"varint,3,opt,name=page_num,json=pageNum,proto3" json:"page_num,omitempty"`
	TotalPage    uint64 `protobuf:"varint,4,opt,name=total_page,json=totalPage,proto3" json:"total_page,omitempty"`
}

func (m *Page) Reset()         { *m = Page{} }
func (m *Page) String() string { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()    {}
func (*Page) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{1}
}
func (m *Page) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Page) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Page.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Page) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Page.Merge(m, src)
}
func (m *Page) XXX_Size() int {
	return m.Size()
}
func (m *Page) XXX_DiscardUnknown() {
	xxx_messageInfo_Page.DiscardUnknown(m)
}

var xxx_messageInfo_Page proto.InternalMessageInfo

func (m *Page) GetTotalRecords() uint64 {
	if m != nil {
		return m.TotalRecords
	}
	return 0
}

func (m *Page) GetPageSize() uint64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *Page) GetPageNum() uint64 {
	if m != nil {
		return m.PageNum
	}
	return 0
}

func (m *Page) GetTotalPage() uint64 {
	if m != nil {
		return m.TotalPage
	}
	return 0
}

type TestRequest struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *TestRequest) Reset()         { *m = TestRequest{} }
func (m *TestRequest) String() string { return proto.CompactTextString(m) }
func (*TestRequest) ProtoMessage()    {}
func (*TestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{2}
}
func (m *TestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRequest.Merge(m, src)
}
func (m *TestRequest) XXX_Size() int {
	return m.Size()
}
func (m *TestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TestRequest proto.InternalMessageInfo

func (m *TestRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type TestResponse struct {
	Code uint64 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *TestResponse) Reset()         { *m = TestResponse{} }
func (m *TestResponse) String() string { return proto.CompactTextString(m) }
func (*TestResponse) ProtoMessage()    {}
func (*TestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{3}
}
func (m *TestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResponse.Merge(m, src)
}
func (m *TestResponse) XXX_Size() int {
	return m.Size()
}
func (m *TestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TestResponse proto.InternalMessageInfo

func (m *TestResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

type SyncSwapOrderRequest struct {
}

func (m *SyncSwapOrderRequest) Reset()         { *m = SyncSwapOrderRequest{} }
func (m *SyncSwapOrderRequest) String() string { return proto.CompactTextString(m) }
func (*SyncSwapOrderRequest) ProtoMessage()    {}
func (*SyncSwapOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{4}
}
func (m *SyncSwapOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncSwapOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncSwapOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncSwapOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncSwapOrderRequest.Merge(m, src)
}
func (m *SyncSwapOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *SyncSwapOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncSwapOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncSwapOrderRequest proto.InternalMessageInfo

type SyncSwapOrderResponse struct {
	Code uint64 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *SyncSwapOrderResponse) Reset()         { *m = SyncSwapOrderResponse{} }
func (m *SyncSwapOrderResponse) String() string { return proto.CompactTextString(m) }
func (*SyncSwapOrderResponse) ProtoMessage()    {}
func (*SyncSwapOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{5}
}
func (m *SyncSwapOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncSwapOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncSwapOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncSwapOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncSwapOrderResponse.Merge(m, src)
}
func (m *SyncSwapOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *SyncSwapOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncSwapOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncSwapOrderResponse proto.InternalMessageInfo

func (m *SyncSwapOrderResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

type SwapProvider struct {
	Key  string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Logo string `protobuf:"bytes,3,opt,name=logo,proto3" json:"logo,omitempty"`
}

func (m *SwapProvider) Reset()         { *m = SwapProvider{} }
func (m *SwapProvider) String() string { return proto.CompactTextString(m) }
func (*SwapProvider) ProtoMessage()    {}
func (*SwapProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{6}
}
func (m *SwapProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapProvider.Merge(m, src)
}
func (m *SwapProvider) XXX_Size() int {
	return m.Size()
}
func (m *SwapProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapProvider.DiscardUnknown(m)
}

var xxx_messageInfo_SwapProvider proto.InternalMessageInfo

func (m *SwapProvider) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SwapProvider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SwapProvider) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

type Token struct {
	Address  string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Decimals int32  `protobuf:"varint,2,opt,name=decimals,proto3" json:"decimals,omitempty"`
	LogoUri  string `protobuf:"bytes,3,opt,name=logo_uri,json=logoUri,proto3" json:"logo_uri,omitempty"`
	Name     string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Symbol   string `protobuf:"bytes,5,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Price    string `protobuf:"bytes,6,opt,name=price,proto3" json:"price,omitempty"`
	Value    string `protobuf:"bytes,7,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Token) Reset()         { *m = Token{} }
func (m *Token) String() string { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()    {}
func (*Token) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{7}
}
func (m *Token) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Token) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Token.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Token) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Token.Merge(m, src)
}
func (m *Token) XXX_Size() int {
	return m.Size()
}
func (m *Token) XXX_DiscardUnknown() {
	xxx_messageInfo_Token.DiscardUnknown(m)
}

var xxx_messageInfo_Token proto.InternalMessageInfo

func (m *Token) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Token) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *Token) GetLogoUri() string {
	if m != nil {
		return m.LogoUri
	}
	return ""
}

func (m *Token) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Token) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Token) GetPrice() string {
	if m != nil {
		return m.Price
	}
	return ""
}

func (m *Token) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Transaction struct {
	Hash        string `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	Gas         string `protobuf:"bytes,2,opt,name=gas,proto3" json:"gas,omitempty"`
	BlockNumber int64  `protobuf:"varint,3,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	GasUsed     string `protobuf:"bytes,4,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	GasPrice    string `protobuf:"bytes,5,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	Nonce       string `protobuf:"bytes,6,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{8}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

func (m *Transaction) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Transaction) GetGas() string {
	if m != nil {
		return m.Gas
	}
	return ""
}

func (m *Transaction) GetBlockNumber() int64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *Transaction) GetGasUsed() string {
	if m != nil {
		return m.GasUsed
	}
	return ""
}

func (m *Transaction) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *Transaction) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

type SwapOrder struct {
	Id              string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ChainID         uint64        `protobuf:"varint,2,opt,name=chainID,proto3" json:"chainID,omitempty"`
	FromAddress     string        `protobuf:"bytes,3,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	DestReceiver    string        `protobuf:"bytes,4,opt,name=dest_receiver,json=destReceiver,proto3" json:"dest_receiver,omitempty"`
	ReceiptStatus   int32         `protobuf:"varint,5,opt,name=receipt_status,json=receiptStatus,proto3" json:"receipt_status,omitempty"`
	FromToken       *Token        `protobuf:"bytes,6,opt,name=from_token,json=fromToken,proto3" json:"from_token,omitempty"`
	ToToken         *Token        `protobuf:"bytes,7,opt,name=to_token,json=toToken,proto3" json:"to_token,omitempty"`
	Provider        *SwapProvider `protobuf:"bytes,8,opt,name=provider,proto3" json:"provider,omitempty"`
	ContractAddress string        `protobuf:"bytes,9,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	BlockAt         int64         `protobuf:"varint,10,opt,name=block_at,json=blockAt,proto3" json:"block_at,omitempty"`
	Tx              *Transaction  `protobuf:"bytes,11,opt,name=tx,proto3" json:"tx,omitempty"`
	TransactionFee  string        `protobuf:"bytes,12,opt,name=transaction_fee,json=transactionFee,proto3" json:"transaction_fee,omitempty"`
	NativeToken     *Token        `protobuf:"bytes,13,opt,name=native_token,json=nativeToken,proto3" json:"native_token,omitempty"`
}

func (m *SwapOrder) Reset()         { *m = SwapOrder{} }
func (m *SwapOrder) String() string { return proto.CompactTextString(m) }
func (*SwapOrder) ProtoMessage()    {}
func (*SwapOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{9}
}
func (m *SwapOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapOrder.Merge(m, src)
}
func (m *SwapOrder) XXX_Size() int {
	return m.Size()
}
func (m *SwapOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SwapOrder proto.InternalMessageInfo

func (m *SwapOrder) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapOrder) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *SwapOrder) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *SwapOrder) GetDestReceiver() string {
	if m != nil {
		return m.DestReceiver
	}
	return ""
}

func (m *SwapOrder) GetReceiptStatus() int32 {
	if m != nil {
		return m.ReceiptStatus
	}
	return 0
}

func (m *SwapOrder) GetFromToken() *Token {
	if m != nil {
		return m.FromToken
	}
	return nil
}

func (m *SwapOrder) GetToToken() *Token {
	if m != nil {
		return m.ToToken
	}
	return nil
}

func (m *SwapOrder) GetProvider() *SwapProvider {
	if m != nil {
		return m.Provider
	}
	return nil
}

func (m *SwapOrder) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *SwapOrder) GetBlockAt() int64 {
	if m != nil {
		return m.BlockAt
	}
	return 0
}

func (m *SwapOrder) GetTx() *Transaction {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *SwapOrder) GetTransactionFee() string {
	if m != nil {
		return m.TransactionFee
	}
	return ""
}

func (m *SwapOrder) GetNativeToken() *Token {
	if m != nil {
		return m.NativeToken
	}
	return nil
}

type SwapOrderPageRequest struct {
	ChainID     uint64 `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	FromAddress string `protobuf:"bytes,2,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	Paginator   *Page  `protobuf:"bytes,3,opt,name=paginator,proto3" json:"paginator,omitempty"`
}

func (m *SwapOrderPageRequest) Reset()         { *m = SwapOrderPageRequest{} }
func (m *SwapOrderPageRequest) String() string { return proto.CompactTextString(m) }
func (*SwapOrderPageRequest) ProtoMessage()    {}
func (*SwapOrderPageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{10}
}
func (m *SwapOrderPageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapOrderPageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapOrderPageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapOrderPageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapOrderPageRequest.Merge(m, src)
}
func (m *SwapOrderPageRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapOrderPageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapOrderPageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapOrderPageRequest proto.InternalMessageInfo

func (m *SwapOrderPageRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *SwapOrderPageRequest) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *SwapOrderPageRequest) GetPaginator() *Page {
	if m != nil {
		return m.Paginator
	}
	return nil
}

type SwapOrderPageResponse struct {
	Code      uint64       `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data      []*SwapOrder `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
	Paginator *Page        `protobuf:"bytes,3,opt,name=paginator,proto3" json:"paginator,omitempty"`
}

func (m *SwapOrderPageResponse) Reset()         { *m = SwapOrderPageResponse{} }
func (m *SwapOrderPageResponse) String() string { return proto.CompactTextString(m) }
func (*SwapOrderPageResponse) ProtoMessage()    {}
func (*SwapOrderPageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{11}
}
func (m *SwapOrderPageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapOrderPageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapOrderPageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapOrderPageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapOrderPageResponse.Merge(m, src)
}
func (m *SwapOrderPageResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapOrderPageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapOrderPageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapOrderPageResponse proto.InternalMessageInfo

func (m *SwapOrderPageResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SwapOrderPageResponse) GetData() []*SwapOrder {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SwapOrderPageResponse) GetPaginator() *Page {
	if m != nil {
		return m.Paginator
	}
	return nil
}

type FindSwapOrderRequest struct {
	ChainID     uint64 `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	TxHash      string `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	FromAddress string `protobuf:"bytes,3,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
}

func (m *FindSwapOrderRequest) Reset()         { *m = FindSwapOrderRequest{} }
func (m *FindSwapOrderRequest) String() string { return proto.CompactTextString(m) }
func (*FindSwapOrderRequest) ProtoMessage()    {}
func (*FindSwapOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{12}
}
func (m *FindSwapOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindSwapOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindSwapOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindSwapOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindSwapOrderRequest.Merge(m, src)
}
func (m *FindSwapOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindSwapOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindSwapOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindSwapOrderRequest proto.InternalMessageInfo

func (m *FindSwapOrderRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *FindSwapOrderRequest) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *FindSwapOrderRequest) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

type FindSwapOrderResponse struct {
	Code uint64     `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data *SwapOrder `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *FindSwapOrderResponse) Reset()         { *m = FindSwapOrderResponse{} }
func (m *FindSwapOrderResponse) String() string { return proto.CompactTextString(m) }
func (*FindSwapOrderResponse) ProtoMessage()    {}
func (*FindSwapOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{13}
}
func (m *FindSwapOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindSwapOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindSwapOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindSwapOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindSwapOrderResponse.Merge(m, src)
}
func (m *FindSwapOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *FindSwapOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindSwapOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindSwapOrderResponse proto.InternalMessageInfo

func (m *FindSwapOrderResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FindSwapOrderResponse) GetData() *SwapOrder {
	if m != nil {
		return m.Data
	}
	return nil
}

type ListSwapTokenRequest struct {
	ChainID      uint64 `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	TokenAddress string `protobuf:"bytes,2,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
}

func (m *ListSwapTokenRequest) Reset()         { *m = ListSwapTokenRequest{} }
func (m *ListSwapTokenRequest) String() string { return proto.CompactTextString(m) }
func (*ListSwapTokenRequest) ProtoMessage()    {}
func (*ListSwapTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{14}
}
func (m *ListSwapTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSwapTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSwapTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSwapTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSwapTokenRequest.Merge(m, src)
}
func (m *ListSwapTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListSwapTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSwapTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSwapTokenRequest proto.InternalMessageInfo

func (m *ListSwapTokenRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *ListSwapTokenRequest) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

type ListSwapTokenResponse struct {
	Code uint64   `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data []*Token `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *ListSwapTokenResponse) Reset()         { *m = ListSwapTokenResponse{} }
func (m *ListSwapTokenResponse) String() string { return proto.CompactTextString(m) }
func (*ListSwapTokenResponse) ProtoMessage()    {}
func (*ListSwapTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{15}
}
func (m *ListSwapTokenResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListSwapTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListSwapTokenResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListSwapTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSwapTokenResponse.Merge(m, src)
}
func (m *ListSwapTokenResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListSwapTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSwapTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSwapTokenResponse proto.InternalMessageInfo

func (m *ListSwapTokenResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ListSwapTokenResponse) GetData() []*Token {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetSwapApproveAllowanceRequest struct {
	ChainID           uint64 `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	TokenAddress      string `protobuf:"bytes,2,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	WalletAddress     string `protobuf:"bytes,3,opt,name=wallet_address,json=walletAddress,proto3" json:"wallet_address,omitempty"`
	AggregatorAddress string `protobuf:"bytes,4,opt,name=aggregator_address,json=aggregatorAddress,proto3" json:"aggregator_address,omitempty"`
}

func (m *GetSwapApproveAllowanceRequest) Reset()         { *m = GetSwapApproveAllowanceRequest{} }
func (m *GetSwapApproveAllowanceRequest) String() string { return proto.CompactTextString(m) }
func (*GetSwapApproveAllowanceRequest) ProtoMessage()    {}
func (*GetSwapApproveAllowanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{16}
}
func (m *GetSwapApproveAllowanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSwapApproveAllowanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSwapApproveAllowanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSwapApproveAllowanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSwapApproveAllowanceRequest.Merge(m, src)
}
func (m *GetSwapApproveAllowanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetSwapApproveAllowanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSwapApproveAllowanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetSwapApproveAllowanceRequest proto.InternalMessageInfo

func (m *GetSwapApproveAllowanceRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *GetSwapApproveAllowanceRequest) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *GetSwapApproveAllowanceRequest) GetWalletAddress() string {
	if m != nil {
		return m.WalletAddress
	}
	return ""
}

func (m *GetSwapApproveAllowanceRequest) GetAggregatorAddress() string {
	if m != nil {
		return m.AggregatorAddress
	}
	return ""
}

type GetSwapApproveAllowanceResponse struct {
	Code      uint64 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Allowance string `protobuf:"bytes,2,opt,name=allowance,proto3" json:"allowance,omitempty"`
}

func (m *GetSwapApproveAllowanceResponse) Reset()         { *m = GetSwapApproveAllowanceResponse{} }
func (m *GetSwapApproveAllowanceResponse) String() string { return proto.CompactTextString(m) }
func (*GetSwapApproveAllowanceResponse) ProtoMessage()    {}
func (*GetSwapApproveAllowanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{17}
}
func (m *GetSwapApproveAllowanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSwapApproveAllowanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSwapApproveAllowanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSwapApproveAllowanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSwapApproveAllowanceResponse.Merge(m, src)
}
func (m *GetSwapApproveAllowanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetSwapApproveAllowanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSwapApproveAllowanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetSwapApproveAllowanceResponse proto.InternalMessageInfo

func (m *GetSwapApproveAllowanceResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GetSwapApproveAllowanceResponse) GetAllowance() string {
	if m != nil {
		return m.Allowance
	}
	return ""
}

type ApproveSwapTransactionRequest struct {
	ChainID           uint64 `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	TokenAddress      string `protobuf:"bytes,2,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	Amount            string `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	AggregatorAddress string `protobuf:"bytes,4,opt,name=aggregator_address,json=aggregatorAddress,proto3" json:"aggregator_address,omitempty"`
}

func (m *ApproveSwapTransactionRequest) Reset()         { *m = ApproveSwapTransactionRequest{} }
func (m *ApproveSwapTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*ApproveSwapTransactionRequest) ProtoMessage()    {}
func (*ApproveSwapTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{18}
}
func (m *ApproveSwapTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApproveSwapTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApproveSwapTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApproveSwapTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApproveSwapTransactionRequest.Merge(m, src)
}
func (m *ApproveSwapTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *ApproveSwapTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ApproveSwapTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ApproveSwapTransactionRequest proto.InternalMessageInfo

func (m *ApproveSwapTransactionRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *ApproveSwapTransactionRequest) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *ApproveSwapTransactionRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *ApproveSwapTransactionRequest) GetAggregatorAddress() string {
	if m != nil {
		return m.AggregatorAddress
	}
	return ""
}

type ApproveSwapTransactionResponse struct {
	Code     uint64 `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data     string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	To       string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	GasPrice string `protobuf:"bytes,4,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	Value    string `protobuf:"bytes,5,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ApproveSwapTransactionResponse) Reset()         { *m = ApproveSwapTransactionResponse{} }
func (m *ApproveSwapTransactionResponse) String() string { return proto.CompactTextString(m) }
func (*ApproveSwapTransactionResponse) ProtoMessage()    {}
func (*ApproveSwapTransactionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{19}
}
func (m *ApproveSwapTransactionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApproveSwapTransactionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApproveSwapTransactionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApproveSwapTransactionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApproveSwapTransactionResponse.Merge(m, src)
}
func (m *ApproveSwapTransactionResponse) XXX_Size() int {
	return m.Size()
}
func (m *ApproveSwapTransactionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ApproveSwapTransactionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ApproveSwapTransactionResponse proto.InternalMessageInfo

func (m *ApproveSwapTransactionResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ApproveSwapTransactionResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *ApproveSwapTransactionResponse) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *ApproveSwapTransactionResponse) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *ApproveSwapTransactionResponse) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type SwapQuoteRequest struct {
	ChainID          uint64 `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	Amount           string `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	FromTokenAddress string `protobuf:"bytes,3,opt,name=from_token_address,json=fromTokenAddress,proto3" json:"from_token_address,omitempty"`
	ToTokenAddress   string `protobuf:"bytes,4,opt,name=to_token_address,json=toTokenAddress,proto3" json:"to_token_address,omitempty"`
}

func (m *SwapQuoteRequest) Reset()         { *m = SwapQuoteRequest{} }
func (m *SwapQuoteRequest) String() string { return proto.CompactTextString(m) }
func (*SwapQuoteRequest) ProtoMessage()    {}
func (*SwapQuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{20}
}
func (m *SwapQuoteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapQuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapQuoteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapQuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapQuoteRequest.Merge(m, src)
}
func (m *SwapQuoteRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapQuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapQuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapQuoteRequest proto.InternalMessageInfo

func (m *SwapQuoteRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *SwapQuoteRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SwapQuoteRequest) GetFromTokenAddress() string {
	if m != nil {
		return m.FromTokenAddress
	}
	return ""
}

func (m *SwapQuoteRequest) GetToTokenAddress() string {
	if m != nil {
		return m.ToTokenAddress
	}
	return ""
}

type SwapQuoteInfo struct {
	Fee              float32     `protobuf:"fixed32,1,opt,name=fee,proto3" json:"fee,omitempty"`
	EstimateGasFee   string      `protobuf:"bytes,2,opt,name=estimate_gas_fee,json=estimateGasFee,proto3" json:"estimate_gas_fee,omitempty"`
	Aggregator       *Aggregator `protobuf:"bytes,3,opt,name=aggregator,proto3" json:"aggregator,omitempty"`
	FromTokenAddress string      `protobuf:"bytes,4,opt,name=from_token_address,json=fromTokenAddress,proto3" json:"from_token_address,omitempty"`
	ToTokenAddress   string      `protobuf:"bytes,5,opt,name=to_token_address,json=toTokenAddress,proto3" json:"to_token_address,omitempty"`
	FromTokenAmount  string      `protobuf:"bytes,6,opt,name=from_token_amount,json=fromTokenAmount,proto3" json:"from_token_amount,omitempty"`
	ToTokenAmount    string      `protobuf:"bytes,7,opt,name=to_token_amount,json=toTokenAmount,proto3" json:"to_token_amount,omitempty"`
	Error            string      `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	FetchTime        int64       `protobuf:"varint,9,opt,name=fetch_time,json=fetchTime,proto3" json:"fetch_time,omitempty"`
}

func (m *SwapQuoteInfo) Reset()         { *m = SwapQuoteInfo{} }
func (m *SwapQuoteInfo) String() string { return proto.CompactTextString(m) }
func (*SwapQuoteInfo) ProtoMessage()    {}
func (*SwapQuoteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{21}
}
func (m *SwapQuoteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapQuoteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapQuoteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapQuoteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapQuoteInfo.Merge(m, src)
}
func (m *SwapQuoteInfo) XXX_Size() int {
	return m.Size()
}
func (m *SwapQuoteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapQuoteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SwapQuoteInfo proto.InternalMessageInfo

func (m *SwapQuoteInfo) GetFee() float32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *SwapQuoteInfo) GetEstimateGasFee() string {
	if m != nil {
		return m.EstimateGasFee
	}
	return ""
}

func (m *SwapQuoteInfo) GetAggregator() *Aggregator {
	if m != nil {
		return m.Aggregator
	}
	return nil
}

func (m *SwapQuoteInfo) GetFromTokenAddress() string {
	if m != nil {
		return m.FromTokenAddress
	}
	return ""
}

func (m *SwapQuoteInfo) GetToTokenAddress() string {
	if m != nil {
		return m.ToTokenAddress
	}
	return ""
}

func (m *SwapQuoteInfo) GetFromTokenAmount() string {
	if m != nil {
		return m.FromTokenAmount
	}
	return ""
}

func (m *SwapQuoteInfo) GetToTokenAmount() string {
	if m != nil {
		return m.ToTokenAmount
	}
	return ""
}

func (m *SwapQuoteInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *SwapQuoteInfo) GetFetchTime() int64 {
	if m != nil {
		return m.FetchTime
	}
	return 0
}

type SwapQuoteResponse struct {
	Code uint64           `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data []*SwapQuoteInfo `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *SwapQuoteResponse) Reset()         { *m = SwapQuoteResponse{} }
func (m *SwapQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*SwapQuoteResponse) ProtoMessage()    {}
func (*SwapQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{22}
}
func (m *SwapQuoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapQuoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapQuoteResponse.Merge(m, src)
}
func (m *SwapQuoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapQuoteResponse proto.InternalMessageInfo

func (m *SwapQuoteResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SwapQuoteResponse) GetData() []*SwapQuoteInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type SwapTradesRequest struct {
	ChainID           uint64  `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	Amount            string  `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	FromTokenAddress  string  `protobuf:"bytes,3,opt,name=from_token_address,json=fromTokenAddress,proto3" json:"from_token_address,omitempty"`
	ToTokenAddress    string  `protobuf:"bytes,4,opt,name=to_token_address,json=toTokenAddress,proto3" json:"to_token_address,omitempty"`
	Slippage          float32 `protobuf:"fixed32,5,opt,name=slippage,proto3" json:"slippage,omitempty"`
	FromAddress       string  `protobuf:"bytes,6,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	DestReceiver      string  `protobuf:"bytes,7,opt,name=dest_receiver,json=destReceiver,proto3" json:"dest_receiver,omitempty"`
	AggregatorAddress string  `protobuf:"bytes,8,opt,name=aggregator_address,json=aggregatorAddress,proto3" json:"aggregator_address,omitempty"`
}

func (m *SwapTradesRequest) Reset()         { *m = SwapTradesRequest{} }
func (m *SwapTradesRequest) String() string { return proto.CompactTextString(m) }
func (*SwapTradesRequest) ProtoMessage()    {}
func (*SwapTradesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{23}
}
func (m *SwapTradesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapTradesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapTradesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapTradesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapTradesRequest.Merge(m, src)
}
func (m *SwapTradesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapTradesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapTradesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapTradesRequest proto.InternalMessageInfo

func (m *SwapTradesRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *SwapTradesRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SwapTradesRequest) GetFromTokenAddress() string {
	if m != nil {
		return m.FromTokenAddress
	}
	return ""
}

func (m *SwapTradesRequest) GetToTokenAddress() string {
	if m != nil {
		return m.ToTokenAddress
	}
	return ""
}

func (m *SwapTradesRequest) GetSlippage() float32 {
	if m != nil {
		return m.Slippage
	}
	return 0
}

func (m *SwapTradesRequest) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *SwapTradesRequest) GetDestReceiver() string {
	if m != nil {
		return m.DestReceiver
	}
	return ""
}

func (m *SwapTradesRequest) GetAggregatorAddress() string {
	if m != nil {
		return m.AggregatorAddress
	}
	return ""
}

type SwapTradeRequest struct {
	ChainID           uint64  `protobuf:"varint,1,opt,name=chainID,proto3" json:"chainID,omitempty"`
	Amount            string  `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	FromTokenAddress  string  `protobuf:"bytes,3,opt,name=from_token_address,json=fromTokenAddress,proto3" json:"from_token_address,omitempty"`
	ToTokenAddress    string  `protobuf:"bytes,4,opt,name=to_token_address,json=toTokenAddress,proto3" json:"to_token_address,omitempty"`
	Slippage          float32 `protobuf:"fixed32,5,opt,name=slippage,proto3" json:"slippage,omitempty"`
	FromAddress       string  `protobuf:"bytes,6,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	DestReceiver      string  `protobuf:"bytes,7,opt,name=dest_receiver,json=destReceiver,proto3" json:"dest_receiver,omitempty"`
	AggregatorAddress string  `protobuf:"bytes,8,opt,name=aggregator_address,json=aggregatorAddress,proto3" json:"aggregator_address,omitempty"`
}

func (m *SwapTradeRequest) Reset()         { *m = SwapTradeRequest{} }
func (m *SwapTradeRequest) String() string { return proto.CompactTextString(m) }
func (*SwapTradeRequest) ProtoMessage()    {}
func (*SwapTradeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{24}
}
func (m *SwapTradeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapTradeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapTradeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapTradeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapTradeRequest.Merge(m, src)
}
func (m *SwapTradeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwapTradeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapTradeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapTradeRequest proto.InternalMessageInfo

func (m *SwapTradeRequest) GetChainID() uint64 {
	if m != nil {
		return m.ChainID
	}
	return 0
}

func (m *SwapTradeRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SwapTradeRequest) GetFromTokenAddress() string {
	if m != nil {
		return m.FromTokenAddress
	}
	return ""
}

func (m *SwapTradeRequest) GetToTokenAddress() string {
	if m != nil {
		return m.ToTokenAddress
	}
	return ""
}

func (m *SwapTradeRequest) GetSlippage() float32 {
	if m != nil {
		return m.Slippage
	}
	return 0
}

func (m *SwapTradeRequest) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *SwapTradeRequest) GetDestReceiver() string {
	if m != nil {
		return m.DestReceiver
	}
	return ""
}

func (m *SwapTradeRequest) GetAggregatorAddress() string {
	if m != nil {
		return m.AggregatorAddress
	}
	return ""
}

type SwapTradeResponse struct {
	Code float32        `protobuf:"fixed32,1,opt,name=code,proto3" json:"code,omitempty"`
	Data *SwapTradeInfo `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *SwapTradeResponse) Reset()         { *m = SwapTradeResponse{} }
func (m *SwapTradeResponse) String() string { return proto.CompactTextString(m) }
func (*SwapTradeResponse) ProtoMessage()    {}
func (*SwapTradeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{25}
}
func (m *SwapTradeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapTradeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapTradeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapTradeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapTradeResponse.Merge(m, src)
}
func (m *SwapTradeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapTradeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapTradeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapTradeResponse proto.InternalMessageInfo

func (m *SwapTradeResponse) GetCode() float32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SwapTradeResponse) GetData() *SwapTradeInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type SwapTradeInfo struct {
	Fee              float32     `protobuf:"fixed32,1,opt,name=fee,proto3" json:"fee,omitempty"`
	Trade            *Trade      `protobuf:"bytes,2,opt,name=trade,proto3" json:"trade,omitempty"`
	Aggregator       *Aggregator `protobuf:"bytes,3,opt,name=aggregator,proto3" json:"aggregator,omitempty"`
	FromTokenAddress string      `protobuf:"bytes,4,opt,name=from_token_address,json=fromTokenAddress,proto3" json:"from_token_address,omitempty"`
	ToTokenAddress   string      `protobuf:"bytes,5,opt,name=to_token_address,json=toTokenAddress,proto3" json:"to_token_address,omitempty"`
	FromTokenAmount  string      `protobuf:"bytes,6,opt,name=from_token_amount,json=fromTokenAmount,proto3" json:"from_token_amount,omitempty"`
	ToTokenAmount    string      `protobuf:"bytes,7,opt,name=to_token_amount,json=toTokenAmount,proto3" json:"to_token_amount,omitempty"`
	Error            string      `protobuf:"bytes,8,opt,name=error,proto3" json:"error,omitempty"`
	FetchTime        int64       `protobuf:"varint,9,opt,name=fetch_time,json=fetchTime,proto3" json:"fetch_time,omitempty"`
}

func (m *SwapTradeInfo) Reset()         { *m = SwapTradeInfo{} }
func (m *SwapTradeInfo) String() string { return proto.CompactTextString(m) }
func (*SwapTradeInfo) ProtoMessage()    {}
func (*SwapTradeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{26}
}
func (m *SwapTradeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapTradeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapTradeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapTradeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapTradeInfo.Merge(m, src)
}
func (m *SwapTradeInfo) XXX_Size() int {
	return m.Size()
}
func (m *SwapTradeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapTradeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SwapTradeInfo proto.InternalMessageInfo

func (m *SwapTradeInfo) GetFee() float32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *SwapTradeInfo) GetTrade() *Trade {
	if m != nil {
		return m.Trade
	}
	return nil
}

func (m *SwapTradeInfo) GetAggregator() *Aggregator {
	if m != nil {
		return m.Aggregator
	}
	return nil
}

func (m *SwapTradeInfo) GetFromTokenAddress() string {
	if m != nil {
		return m.FromTokenAddress
	}
	return ""
}

func (m *SwapTradeInfo) GetToTokenAddress() string {
	if m != nil {
		return m.ToTokenAddress
	}
	return ""
}

func (m *SwapTradeInfo) GetFromTokenAmount() string {
	if m != nil {
		return m.FromTokenAmount
	}
	return ""
}

func (m *SwapTradeInfo) GetToTokenAmount() string {
	if m != nil {
		return m.ToTokenAmount
	}
	return ""
}

func (m *SwapTradeInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *SwapTradeInfo) GetFetchTime() int64 {
	if m != nil {
		return m.FetchTime
	}
	return 0
}

type SwapTradesResponse struct {
	Code uint64           `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Data []*SwapTradeInfo `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *SwapTradesResponse) Reset()         { *m = SwapTradesResponse{} }
func (m *SwapTradesResponse) String() string { return proto.CompactTextString(m) }
func (*SwapTradesResponse) ProtoMessage()    {}
func (*SwapTradesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{27}
}
func (m *SwapTradesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwapTradesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwapTradesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SwapTradesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapTradesResponse.Merge(m, src)
}
func (m *SwapTradesResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwapTradesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapTradesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapTradesResponse proto.InternalMessageInfo

func (m *SwapTradesResponse) GetCode() uint64 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SwapTradesResponse) GetData() []*SwapTradeInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type Trade struct {
	Data     string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	From     string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To       string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	GasPrice string `protobuf:"bytes,4,opt,name=gas_price,json=gasPrice,proto3" json:"gas_price,omitempty"`
	GasLimit string `protobuf:"bytes,5,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	Value    string `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Trade) Reset()         { *m = Trade{} }
func (m *Trade) String() string { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()    {}
func (*Trade) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{28}
}
func (m *Trade) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trade) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trade.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trade) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trade.Merge(m, src)
}
func (m *Trade) XXX_Size() int {
	return m.Size()
}
func (m *Trade) XXX_DiscardUnknown() {
	xxx_messageInfo_Trade.DiscardUnknown(m)
}

var xxx_messageInfo_Trade proto.InternalMessageInfo

func (m *Trade) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Trade) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Trade) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Trade) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *Trade) GetGasLimit() string {
	if m != nil {
		return m.GasLimit
	}
	return ""
}

func (m *Trade) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Aggregator struct {
	Type            string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Name            string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ContractAddress string `protobuf:"bytes,3,opt,name=contract_address,json=contractAddress,proto3" json:"contract_address,omitempty"`
	Logo            string `protobuf:"bytes,4,opt,name=logo,proto3" json:"logo,omitempty"`
}

func (m *Aggregator) Reset()         { *m = Aggregator{} }
func (m *Aggregator) String() string { return proto.CompactTextString(m) }
func (*Aggregator) ProtoMessage()    {}
func (*Aggregator) Descriptor() ([]byte, []int) {
	return fileDescriptor_3d5fea29261f89b9, []int{29}
}
func (m *Aggregator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregator.Merge(m, src)
}
func (m *Aggregator) XXX_Size() int {
	return m.Size()
}
func (m *Aggregator) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregator.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregator proto.InternalMessageInfo

func (m *Aggregator) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Aggregator) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Aggregator) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *Aggregator) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

func init() {
	proto.RegisterType((*PageQuick)(nil), "swapsvc.PageQuick")
	proto.RegisterType((*Page)(nil), "swapsvc.Page")
	proto.RegisterType((*TestRequest)(nil), "swapsvc.TestRequest")
	proto.RegisterType((*TestResponse)(nil), "swapsvc.TestResponse")
	proto.RegisterType((*SyncSwapOrderRequest)(nil), "swapsvc.SyncSwapOrderRequest")
	proto.RegisterType((*SyncSwapOrderResponse)(nil), "swapsvc.SyncSwapOrderResponse")
	proto.RegisterType((*SwapProvider)(nil), "swapsvc.SwapProvider")
	proto.RegisterType((*Token)(nil), "swapsvc.Token")
	proto.RegisterType((*Transaction)(nil), "swapsvc.Transaction")
	proto.RegisterType((*SwapOrder)(nil), "swapsvc.SwapOrder")
	proto.RegisterType((*SwapOrderPageRequest)(nil), "swapsvc.SwapOrderPageRequest")
	proto.RegisterType((*SwapOrderPageResponse)(nil), "swapsvc.SwapOrderPageResponse")
	proto.RegisterType((*FindSwapOrderRequest)(nil), "swapsvc.FindSwapOrderRequest")
	proto.RegisterType((*FindSwapOrderResponse)(nil), "swapsvc.FindSwapOrderResponse")
	proto.RegisterType((*ListSwapTokenRequest)(nil), "swapsvc.ListSwapTokenRequest")
	proto.RegisterType((*ListSwapTokenResponse)(nil), "swapsvc.ListSwapTokenResponse")
	proto.RegisterType((*GetSwapApproveAllowanceRequest)(nil), "swapsvc.GetSwapApproveAllowanceRequest")
	proto.RegisterType((*GetSwapApproveAllowanceResponse)(nil), "swapsvc.GetSwapApproveAllowanceResponse")
	proto.RegisterType((*ApproveSwapTransactionRequest)(nil), "swapsvc.ApproveSwapTransactionRequest")
	proto.RegisterType((*ApproveSwapTransactionResponse)(nil), "swapsvc.ApproveSwapTransactionResponse")
	proto.RegisterType((*SwapQuoteRequest)(nil), "swapsvc.SwapQuoteRequest")
	proto.RegisterType((*SwapQuoteInfo)(nil), "swapsvc.SwapQuoteInfo")
	proto.RegisterType((*SwapQuoteResponse)(nil), "swapsvc.SwapQuoteResponse")
	proto.RegisterType((*SwapTradesRequest)(nil), "swapsvc.SwapTradesRequest")
	proto.RegisterType((*SwapTradeRequest)(nil), "swapsvc.SwapTradeRequest")
	proto.RegisterType((*SwapTradeResponse)(nil), "swapsvc.SwapTradeResponse")
	proto.RegisterType((*SwapTradeInfo)(nil), "swapsvc.SwapTradeInfo")
	proto.RegisterType((*SwapTradesResponse)(nil), "swapsvc.SwapTradesResponse")
	proto.RegisterType((*Trade)(nil), "swapsvc.Trade")
	proto.RegisterType((*Aggregator)(nil), "swapsvc.Aggregator")
}

func init() { proto.RegisterFile("swapsvc.proto", fileDescriptor_3d5fea29261f89b9) }

var fileDescriptor_3d5fea29261f89b9 = []byte{
	// 1732 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0x4b, 0x6f, 0x24, 0x49,
	0x11, 0x9e, 0x2a, 0xf7, 0x33, 0xfa, 0x61, 0x3b, 0xd7, 0x8f, 0x76, 0xb3, 0x6e, 0x66, 0x6b, 0x96,
	0xb1, 0x77, 0x97, 0x99, 0xd2, 0x7a, 0xc5, 0x01, 0x71, 0x40, 0x46, 0xb0, 0xbb, 0x23, 0x8d, 0x76,
	0xbd, 0xd5, 0x9e, 0x8b, 0x2f, 0xad, 0x74, 0x55, 0xba, 0x5d, 0x72, 0x77, 0x55, 0x6f, 0x65, 0xb6,
	0x1f, 0x23, 0x21, 0xa1, 0xb9, 0x72, 0x00, 0x89, 0x2b, 0x47, 0x38, 0xc0, 0x85, 0xb9, 0xf0, 0x1f,
	0x38, 0x8e, 0xc4, 0x85, 0x0b, 0x12, 0xcc, 0xf0, 0x27, 0xb8, 0x20, 0x94, 0x91, 0x59, 0x8f, 0x2e,
	0x57, 0xb7, 0x6d, 0x34, 0x07, 0x0e, 0x73, 0xcb, 0x88, 0x8c, 0x8a, 0xf8, 0xe2, 0x91, 0x11, 0x99,
	0x05, 0x2d, 0x7e, 0x41, 0x27, 0xfc, 0xdc, 0x7d, 0x3c, 0x89, 0x42, 0x11, 0x92, 0xaa, 0x26, 0xbb,
	0x3f, 0x1b, 0xfa, 0xe2, 0x74, 0x7a, 0xfc, 0xd8, 0x0d, 0xc7, 0xf6, 0x98, 0x09, 0x7a, 0xce, 0x22,
	0xce, 0x6c, 0x11, 0x4d, 0x39, 0xb7, 0x3d, 0x76, 0x22, 0x22, 0xc6, 0xec, 0x61, 0x18, 0x0e, 0x47,
	0x4c, 0x9c, 0xfa, 0x91, 0x37, 0xa1, 0x91, 0xb8, 0xb2, 0x69, 0x10, 0x84, 0x82, 0x0a, 0x3f, 0x0c,
	0xb8, 0xd2, 0x67, 0x1d, 0x40, 0xfd, 0x80, 0x0e, 0xd9, 0x37, 0x53, 0xdf, 0x3d, 0x23, 0x6b, 0x50,
	0x1e, 0xf9, 0x63, 0x5f, 0x74, 0x8c, 0xfb, 0xc6, 0x6e, 0xc9, 0x51, 0x04, 0xd9, 0x84, 0x6a, 0xc0,
	0x2e, 0xc5, 0xc0, 0xf7, 0x3a, 0xe6, 0x7d, 0x63, 0xb7, 0xee, 0x54, 0x24, 0xf9, 0xc4, 0x93, 0xe2,
	0x22, 0x14, 0x74, 0xd4, 0x59, 0x52, 0xe2, 0x48, 0x58, 0x2f, 0x0c, 0x28, 0x49, 0x95, 0xe4, 0x01,
	0xb4, 0x90, 0x33, 0x88, 0x98, 0x1b, 0x46, 0x1e, 0xd7, 0x5a, 0x9b, 0xc8, 0x74, 0x14, 0x8f, 0x7c,
	0x07, 0xea, 0x13, 0x3a, 0x64, 0x03, 0xee, 0x3f, 0x67, 0xa8, 0xbe, 0xe4, 0xd4, 0x24, 0xa3, 0xef,
	0x3f, 0x67, 0x64, 0x0b, 0x70, 0x3d, 0x08, 0xa6, 0x63, 0x6d, 0xa3, 0x2a, 0xe9, 0xaf, 0xa6, 0x63,
	0xb2, 0x0d, 0xa0, 0x94, 0x4b, 0x46, 0xa7, 0x84, 0x9b, 0x75, 0xe4, 0x48, 0xdb, 0xd6, 0x07, 0xd0,
	0x38, 0x64, 0x5c, 0x38, 0xec, 0xdb, 0x29, 0xe3, 0x82, 0x10, 0x28, 0x89, 0xab, 0x09, 0x43, 0x04,
	0x75, 0x07, 0xd7, 0x96, 0x05, 0x4d, 0x25, 0xc2, 0x27, 0x61, 0xc0, 0x99, 0x94, 0x71, 0x43, 0x8f,
	0x69, 0x94, 0xb8, 0xb6, 0x36, 0x60, 0xad, 0x7f, 0x15, 0xb8, 0xfd, 0x0b, 0x3a, 0xf9, 0x3a, 0xf2,
	0x58, 0xa4, 0xf5, 0x59, 0x9f, 0xc0, 0x7a, 0x8e, 0xbf, 0x40, 0xc9, 0x97, 0xd0, 0x94, 0x82, 0x07,
	0x51, 0x78, 0xee, 0x7b, 0x2c, 0x22, 0x2b, 0xb0, 0x74, 0xc6, 0xae, 0x34, 0x16, 0xb9, 0x94, 0x5f,
	0x05, 0x74, 0xcc, 0x74, 0x78, 0x71, 0x2d, 0x79, 0xa3, 0x70, 0x18, 0xa2, 0xdf, 0x75, 0x07, 0xd7,
	0xd6, 0x4b, 0x03, 0xca, 0x87, 0xe1, 0x19, 0x0b, 0x48, 0x07, 0xaa, 0xd4, 0xf3, 0x22, 0xc6, 0xb9,
	0xd6, 0x13, 0x93, 0xa4, 0x0b, 0x35, 0x8f, 0xb9, 0xfe, 0x98, 0x8e, 0x38, 0xea, 0x2b, 0x3b, 0x09,
	0x2d, 0xe3, 0x29, 0xf5, 0x0c, 0xa6, 0x91, 0xaf, 0xf5, 0x56, 0x25, 0xfd, 0x2c, 0xf2, 0x13, 0x08,
	0xa5, 0x0c, 0x84, 0x0d, 0xa8, 0xf0, 0xab, 0xf1, 0x71, 0x38, 0xea, 0x94, 0x55, 0xde, 0x15, 0x25,
	0xf3, 0x3e, 0x89, 0x7c, 0x97, 0x75, 0x2a, 0xc8, 0x56, 0x84, 0xe4, 0x9e, 0xd3, 0xd1, 0x94, 0x75,
	0xaa, 0x8a, 0x8b, 0x84, 0xf5, 0x3b, 0x03, 0x1a, 0x87, 0x11, 0x0d, 0x38, 0x75, 0x65, 0xd9, 0x49,
	0x3b, 0xa7, 0x94, 0x9f, 0xc6, 0x99, 0x90, 0x6b, 0x19, 0x90, 0x21, 0xe5, 0xda, 0x7b, 0xb9, 0x24,
	0x1f, 0x40, 0xf3, 0x78, 0x14, 0xba, 0x67, 0x32, 0xf3, 0xc7, 0x2c, 0x42, 0xb0, 0x4b, 0x4e, 0x03,
	0x79, 0x5f, 0x21, 0x4b, 0xfa, 0x32, 0xa4, 0x7c, 0x30, 0xe5, 0xcc, 0xd3, 0xa0, 0xab, 0x43, 0xca,
	0x9f, 0x71, 0xe6, 0xc9, 0x9a, 0x92, 0x5b, 0x0a, 0xa3, 0x82, 0x2e, 0x65, 0x0f, 0x62, 0x98, 0x41,
	0x18, 0xa4, 0xe0, 0x91, 0xb0, 0xfe, 0xbd, 0x04, 0xf5, 0x24, 0x9b, 0xa4, 0x0d, 0xa6, 0xef, 0x69,
	0x88, 0xa6, 0xef, 0xc9, 0x68, 0xbb, 0xa7, 0xd4, 0x0f, 0x9e, 0xfc, 0x54, 0x97, 0x68, 0x4c, 0x4a,
	0xa0, 0x27, 0x51, 0x38, 0x1e, 0xc4, 0xc9, 0x50, 0x51, 0x6d, 0x48, 0xde, 0xbe, 0x4e, 0xc8, 0x03,
	0x68, 0x79, 0x8c, 0x0b, 0x79, 0x0a, 0x98, 0x7f, 0xce, 0x22, 0x8d, 0xb6, 0xe9, 0x61, 0xf1, 0x29,
	0x1e, 0xf9, 0x1e, 0xb4, 0x71, 0x7f, 0x22, 0x06, 0x5c, 0x50, 0x31, 0xe5, 0x88, 0xbb, 0xec, 0xb4,
	0x34, 0xb7, 0x8f, 0x4c, 0xf2, 0x08, 0x00, 0xcd, 0x09, 0x59, 0x04, 0xe8, 0x41, 0x63, 0xaf, 0xfd,
	0x38, 0xee, 0x10, 0x58, 0x1a, 0x4e, 0x5d, 0x4a, 0xa8, 0x2a, 0xf9, 0x08, 0x6a, 0x22, 0xd4, 0xc2,
	0xd5, 0x42, 0xe1, 0xaa, 0x08, 0x95, 0xe8, 0xa7, 0x50, 0x9b, 0xe8, 0x02, 0xed, 0xd4, 0x50, 0x74,
	0x3d, 0x11, 0xcd, 0x56, 0xaf, 0x93, 0x88, 0x91, 0x8f, 0x60, 0xc5, 0x0d, 0x03, 0x11, 0x51, 0x57,
	0x24, 0xfe, 0xd7, 0xd1, 0xb7, 0xe5, 0x98, 0x1f, 0xc7, 0x60, 0x0b, 0x6a, 0x2a, 0x9f, 0x54, 0x74,
	0x00, 0x73, 0x59, 0x45, 0x7a, 0x5f, 0x90, 0x0f, 0xc1, 0x14, 0x97, 0x9d, 0x06, 0x9a, 0x5c, 0x4b,
	0xd1, 0xa5, 0x25, 0xe3, 0x98, 0xe2, 0x92, 0xec, 0xc0, 0xb2, 0x48, 0x59, 0x83, 0x13, 0xc6, 0x3a,
	0x4d, 0x34, 0xd5, 0xce, 0xb0, 0x3f, 0x67, 0x8c, 0x7c, 0x0a, 0xcd, 0x80, 0x0a, 0xff, 0x9c, 0x69,
	0xb7, 0x5b, 0x85, 0x6e, 0x37, 0x94, 0x0c, 0x12, 0xd6, 0x2f, 0x0c, 0x58, 0x4b, 0x72, 0x2f, 0xbb,
	0x47, 0xdc, 0x35, 0x32, 0x69, 0x37, 0x16, 0xa7, 0xdd, 0xbc, 0x9e, 0xf6, 0x4f, 0xb0, 0xb1, 0xf9,
	0x01, 0x15, 0xa1, 0xaa, 0xdf, 0xc6, 0x5e, 0x2b, 0x41, 0x81, 0x56, 0xd2, 0x7d, 0x09, 0x61, 0x3d,
	0x07, 0x61, 0x7e, 0x43, 0x21, 0x0f, 0xa1, 0xe4, 0x51, 0x41, 0x3b, 0xe6, 0xfd, 0xa5, 0xdd, 0xc6,
	0x1e, 0x99, 0xc9, 0x93, 0x6a, 0x47, 0xb8, 0x7f, 0x37, 0x08, 0x23, 0x58, 0xfb, 0xdc, 0x0f, 0xbc,
	0x7c, 0xab, 0x5b, 0x10, 0x84, 0x4d, 0xa8, 0x8a, 0xcb, 0x01, 0x9e, 0x66, 0x3d, 0x17, 0xc4, 0xe5,
	0x97, 0xf2, 0x3c, 0xdf, 0x7c, 0x28, 0xac, 0x3e, 0xac, 0xe7, 0xac, 0xdd, 0xca, 0x5f, 0x63, 0x91,
	0xbf, 0xd6, 0x33, 0x58, 0x7b, 0xea, 0x73, 0x21, 0xd9, 0x2a, 0xcd, 0x37, 0xba, 0x80, 0x23, 0xea,
	0x8c, 0x05, 0xb9, 0x44, 0x36, 0x91, 0x19, 0x63, 0xfd, 0x1a, 0xd6, 0x73, 0x6a, 0x17, 0x60, 0xb5,
	0x66, 0x72, 0x93, 0xaf, 0x3b, 0x85, 0xf3, 0xcf, 0x06, 0xf4, 0xbe, 0x60, 0xa8, 0x70, 0x7f, 0x22,
	0x8f, 0x13, 0xdb, 0x1f, 0x8d, 0xc2, 0x0b, 0x1a, 0xb8, 0xec, 0xed, 0x40, 0x96, 0xed, 0xe4, 0x82,
	0x8e, 0x46, 0x4c, 0xe4, 0x72, 0xd0, 0x52, 0xdc, 0x58, 0xec, 0x11, 0x10, 0x3a, 0x1c, 0x46, 0x6c,
	0x28, 0x2b, 0x20, 0x11, 0x55, 0xfd, 0x69, 0x35, 0xdd, 0x49, 0x93, 0xf6, 0xdd, 0xb9, 0xb0, 0x17,
	0x84, 0xe4, 0x7d, 0xa8, 0xd3, 0x58, 0x50, 0xa3, 0x4d, 0x19, 0xd6, 0xef, 0x0d, 0xd8, 0xd6, 0xea,
	0x30, 0xc2, 0x99, 0x83, 0xff, 0x76, 0x62, 0xb1, 0x01, 0x15, 0x3a, 0x0e, 0xa7, 0x81, 0xd0, 0x31,
	0xd0, 0xd4, 0x5d, 0x9d, 0xff, 0xa5, 0x01, 0xbd, 0x79, 0x38, 0x17, 0x38, 0x4f, 0x32, 0xb5, 0x5b,
	0xd7, 0xe7, 0xb2, 0x0d, 0xa6, 0x88, 0x07, 0xbb, 0x29, 0xc2, 0xd9, 0x79, 0x55, 0xba, 0x3e, 0xaf,
	0xd4, 0x58, 0x2d, 0x67, 0xc7, 0xea, 0x6f, 0x0d, 0x58, 0x91, 0x30, 0xbe, 0x99, 0x86, 0xe2, 0x16,
	0x45, 0x93, 0xc6, 0xc0, 0x9c, 0x89, 0xc1, 0xf7, 0x81, 0xa4, 0xf3, 0x24, 0x57, 0x2b, 0x2b, 0xc9,
	0x1c, 0x89, 0x23, 0xb9, 0x0b, 0x2b, 0xf1, 0x38, 0xc9, 0xc5, 0xab, 0xad, 0xc7, 0x48, 0x1c, 0xac,
	0x7f, 0x9a, 0xd0, 0x4a, 0xe0, 0x3d, 0x09, 0x4e, 0x42, 0x39, 0xe3, 0x65, 0xd3, 0x96, 0xb8, 0x4c,
	0x47, 0x2e, 0xa5, 0x36, 0xc6, 0x85, 0x3f, 0xa6, 0x82, 0x0d, 0xa4, 0xfb, 0x72, 0x5b, 0xa1, 0x6b,
	0xc7, 0xfc, 0x2f, 0x28, 0x97, 0x3d, 0xfd, 0x33, 0x80, 0x34, 0x1f, 0xba, 0x91, 0xbd, 0x97, 0x9c,
	0xac, 0xfd, 0x64, 0xcb, 0xc9, 0x88, 0xcd, 0x71, 0xad, 0x74, 0x07, 0xd7, 0xca, 0x45, 0xae, 0x91,
	0x8f, 0x61, 0x35, 0xab, 0x57, 0x45, 0x55, 0xdd, 0x25, 0x96, 0x53, 0xb5, 0x2a, 0xbc, 0x0f, 0x61,
	0x39, 0xd5, 0xaa, 0x24, 0xd5, 0xe5, 0xa8, 0x15, 0x2b, 0x55, 0x72, 0x6b, 0x50, 0x66, 0x51, 0x14,
	0xaa, 0xc9, 0x5b, 0x77, 0x14, 0x21, 0xaf, 0xb8, 0x27, 0x4c, 0xb8, 0xa7, 0x03, 0xe1, 0x8f, 0x19,
	0x4e, 0xd6, 0x25, 0xa7, 0x8e, 0x9c, 0x43, 0x7f, 0xcc, 0xac, 0x3e, 0xac, 0x66, 0x2a, 0x60, 0x41,
	0x09, 0x7e, 0x3c, 0xd3, 0x92, 0x36, 0x66, 0xda, 0x67, 0x92, 0x20, 0xdd, 0x9a, 0x5e, 0x9a, 0x4a,
	0xeb, 0x61, 0x44, 0x3d, 0xc6, 0xff, 0xef, 0x0a, 0x4b, 0xde, 0x6e, 0xf9, 0xc8, 0x9f, 0xe0, 0xa5,
	0xbf, 0x8c, 0xb5, 0x94, 0xd0, 0xd7, 0xc6, 0x4e, 0xe5, 0x16, 0x77, 0xb1, 0x6a, 0xc1, 0x5d, 0xac,
	0xb8, 0x31, 0xd4, 0xe6, 0x35, 0x86, 0x3f, 0x99, 0xea, 0x28, 0x62, 0xc8, 0xde, 0x45, 0xec, 0x16,
	0x11, 0xeb, 0x67, 0x6a, 0xac, 0xb0, 0x72, 0xcd, 0x6b, 0x95, 0x6b, 0x5c, 0xab, 0x5c, 0xfc, 0x3a,
	0x53, 0xb9, 0x7f, 0xd7, 0x2d, 0x27, 0xe1, 0x17, 0xb4, 0x9c, 0x0f, 0xa1, 0x2c, 0xe4, 0xb6, 0x56,
	0xd8, 0xce, 0x5e, 0x37, 0x3d, 0xe6, 0xa8, 0xcd, 0x77, 0xed, 0xa6, 0xb0, 0xdd, 0x1c, 0x02, 0xc9,
	0x36, 0x86, 0xff, 0xb1, 0xdf, 0xe4, 0xb3, 0xf6, 0x2b, 0xf9, 0xa2, 0xc5, 0xa8, 0xc7, 0x83, 0xd2,
	0xc8, 0x0c, 0x4a, 0x02, 0x25, 0xe9, 0x63, 0x3c, 0x3c, 0xe5, 0xfa, 0x6e, 0xc3, 0x53, 0x6f, 0xaa,
	0x9f, 0x1a, 0xe9, 0x4b, 0xf0, 0x29, 0xfe, 0xd7, 0x48, 0x26, 0x6b, 0x25, 0x3b, 0x59, 0x39, 0x40,
	0x9a, 0xe2, 0xa2, 0x1f, 0x07, 0x85, 0xaf, 0xf5, 0xa2, 0xb7, 0xd0, 0x52, 0xf1, 0x5b, 0x28, 0x7e,
	0xd8, 0x97, 0xd2, 0x87, 0xfd, 0xde, 0x7f, 0x6a, 0x50, 0xed, 0xab, 0x30, 0x91, 0x9f, 0x43, 0x6b,
	0xe6, 0xdf, 0x02, 0xd9, 0x4e, 0x23, 0x58, 0xf0, 0x2f, 0xa2, 0xdb, 0x9b, 0xb7, 0xad, 0x52, 0x64,
	0x3d, 0x7a, 0xf1, 0xd7, 0x7f, 0xfd, 0xc6, 0xdc, 0x21, 0x2b, 0xb6, 0x94, 0x1b, 0x84, 0x72, 0xd3,
	0xe6, 0x57, 0x81, 0x7b, 0xf4, 0x1e, 0x59, 0xcd, 0xf3, 0x6c, 0x34, 0x9f, 0x7d, 0x89, 0x64, 0xcd,
	0x17, 0x3c, 0x92, 0xb2, 0xe6, 0x8b, 0x1e, 0x30, 0xc5, 0xe6, 0x65, 0xf7, 0xc9, 0x9b, 0x97, 0x3c,
	0x34, 0x3f, 0xf3, 0x30, 0xc8, 0x98, 0x2f, 0x7a, 0x9e, 0x64, 0xcc, 0x17, 0xbe, 0x27, 0x8a, 0xcd,
	0x9f, 0xf8, 0x81, 0x97, 0x37, 0x2f, 0x79, 0x68, 0x7e, 0xe6, 0xae, 0x9f, 0x31, 0x5f, 0xf4, 0xb4,
	0xc8, 0x98, 0x2f, 0x7c, 0x22, 0xe4, 0xcd, 0xe3, 0xd9, 0xb4, 0x47, 0x3e, 0x17, 0xa9, 0xf9, 0x94,
	0x67, 0x93, 0x3f, 0x18, 0xb0, 0x39, 0xe7, 0x8a, 0x4d, 0x76, 0x12, 0x53, 0x8b, 0xdf, 0x0e, 0xdd,
	0xdd, 0x9b, 0x05, 0x35, 0xba, 0x1f, 0x21, 0xba, 0x1f, 0x90, 0x4d, 0x44, 0x62, 0x53, 0x25, 0x67,
	0x27, 0x97, 0xf3, 0xa3, 0x2e, 0xe9, 0xcc, 0xd9, 0xb2, 0xc9, 0x1f, 0x0d, 0xd8, 0x28, 0xbe, 0x10,
	0x93, 0x87, 0x69, 0xb7, 0x5c, 0x74, 0xb3, 0xef, 0xee, 0xdc, 0x28, 0xa7, 0x81, 0xfe, 0x18, 0x81,
	0xfe, 0x90, 0x6c, 0xcd, 0xa2, 0xc9, 0xbc, 0xfd, 0x8f, 0xde, 0x27, 0xdd, 0xb9, 0x9b, 0x36, 0x19,
	0xaa, 0xdf, 0x3b, 0xaa, 0xd5, 0x6c, 0x5d, 0x6f, 0x49, 0x31, 0xa2, 0x6e, 0xd1, 0x96, 0x06, 0xf1,
	0x00, 0x41, 0x6c, 0x93, 0x86, 0xb2, 0x83, 0xc3, 0xe2, 0xa8, 0x4d, 0x9a, 0x19, 0x32, 0x31, 0x84,
	0xf7, 0xaa, 0x9c, 0xa1, 0xec, 0x5d, 0x3d, 0x67, 0x68, 0xe6, 0x12, 0x97, 0x37, 0xf4, 0xad, 0xdc,
	0x4c, 0x0d, 0x21, 0x69, 0x93, 0xa7, 0x50, 0x3a, 0x94, 0x37, 0x8d, 0xcc, 0x3f, 0x93, 0xf4, 0x87,
	0x67, 0x77, 0x3d, 0xc7, 0xd5, 0x9a, 0x37, 0x51, 0xf3, 0x2a, 0x29, 0xdb, 0x82, 0x71, 0x71, 0x54,
	0x23, 0x15, 0x5c, 0xd8, 0x3f, 0xe9, 0xfc, 0xe5, 0x75, 0xcf, 0x78, 0xf5, 0xba, 0x67, 0xfc, 0xe3,
	0x75, 0xcf, 0xf8, 0xf5, 0x9b, 0xde, 0xbd, 0x57, 0x6f, 0x7a, 0xf7, 0xfe, 0xf6, 0xa6, 0x77, 0xef,
	0xb8, 0x82, 0xff, 0x89, 0x3f, 0xfb, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x7b, 0xa2, 0xcc, 0xd8,
	0x88, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SwapsvcClient is the client API for Swapsvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapsvcClient interface {
	SyncSwapOrder(ctx context.Context, in *SyncSwapOrderRequest, opts ...grpc.CallOption) (*SyncSwapOrderResponse, error)
	SwapOrderPage(ctx context.Context, in *SwapOrderPageRequest, opts ...grpc.CallOption) (*SwapOrderPageResponse, error)
	FindSwapOrder(ctx context.Context, in *FindSwapOrderRequest, opts ...grpc.CallOption) (*FindSwapOrderResponse, error)
	ListSwapToken(ctx context.Context, in *ListSwapTokenRequest, opts ...grpc.CallOption) (*ListSwapTokenResponse, error)
	GetSwapApproveAllowance(ctx context.Context, in *GetSwapApproveAllowanceRequest, opts ...grpc.CallOption) (*GetSwapApproveAllowanceResponse, error)
	ApproveSwapTransaction(ctx context.Context, in *ApproveSwapTransactionRequest, opts ...grpc.CallOption) (*ApproveSwapTransactionResponse, error)
	SwapTrade(ctx context.Context, in *SwapTradeRequest, opts ...grpc.CallOption) (*SwapTradeResponse, error)
	SwapQuote(ctx context.Context, in *SwapQuoteRequest, opts ...grpc.CallOption) (*SwapQuoteResponse, error)
	Test(ctx context.Context, in *TestRequest, opts ...grpc.CallOption) (*TestResponse, error)
}

type swapsvcClient struct {
	cc *grpc.ClientConn
}

func NewSwapsvcClient(cc *grpc.ClientConn) SwapsvcClient {
	return &swapsvcClient{cc}
}

func (c *swapsvcClient) SyncSwapOrder(ctx context.Context, in *SyncSwapOrderRequest, opts ...grpc.CallOption) (*SyncSwapOrderResponse, error) {
	out := new(SyncSwapOrderResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/SyncSwapOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) SwapOrderPage(ctx context.Context, in *SwapOrderPageRequest, opts ...grpc.CallOption) (*SwapOrderPageResponse, error) {
	out := new(SwapOrderPageResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/SwapOrderPage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) FindSwapOrder(ctx context.Context, in *FindSwapOrderRequest, opts ...grpc.CallOption) (*FindSwapOrderResponse, error) {
	out := new(FindSwapOrderResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/FindSwapOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) ListSwapToken(ctx context.Context, in *ListSwapTokenRequest, opts ...grpc.CallOption) (*ListSwapTokenResponse, error) {
	out := new(ListSwapTokenResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/ListSwapToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) GetSwapApproveAllowance(ctx context.Context, in *GetSwapApproveAllowanceRequest, opts ...grpc.CallOption) (*GetSwapApproveAllowanceResponse, error) {
	out := new(GetSwapApproveAllowanceResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/GetSwapApproveAllowance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) ApproveSwapTransaction(ctx context.Context, in *ApproveSwapTransactionRequest, opts ...grpc.CallOption) (*ApproveSwapTransactionResponse, error) {
	out := new(ApproveSwapTransactionResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/ApproveSwapTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) SwapTrade(ctx context.Context, in *SwapTradeRequest, opts ...grpc.CallOption) (*SwapTradeResponse, error) {
	out := new(SwapTradeResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/SwapTrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) SwapQuote(ctx context.Context, in *SwapQuoteRequest, opts ...grpc.CallOption) (*SwapQuoteResponse, error) {
	out := new(SwapQuoteResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/SwapQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapsvcClient) Test(ctx context.Context, in *TestRequest, opts ...grpc.CallOption) (*TestResponse, error) {
	out := new(TestResponse)
	err := c.cc.Invoke(ctx, "/swapsvc.Swapsvc/Test", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwapsvcServer is the server API for Swapsvc service.
type SwapsvcServer interface {
	SyncSwapOrder(context.Context, *SyncSwapOrderRequest) (*SyncSwapOrderResponse, error)
	SwapOrderPage(context.Context, *SwapOrderPageRequest) (*SwapOrderPageResponse, error)
	FindSwapOrder(context.Context, *FindSwapOrderRequest) (*FindSwapOrderResponse, error)
	ListSwapToken(context.Context, *ListSwapTokenRequest) (*ListSwapTokenResponse, error)
	GetSwapApproveAllowance(context.Context, *GetSwapApproveAllowanceRequest) (*GetSwapApproveAllowanceResponse, error)
	ApproveSwapTransaction(context.Context, *ApproveSwapTransactionRequest) (*ApproveSwapTransactionResponse, error)
	SwapTrade(context.Context, *SwapTradeRequest) (*SwapTradeResponse, error)
	SwapQuote(context.Context, *SwapQuoteRequest) (*SwapQuoteResponse, error)
	Test(context.Context, *TestRequest) (*TestResponse, error)
}

// UnimplementedSwapsvcServer can be embedded to have forward compatible implementations.
type UnimplementedSwapsvcServer struct {
}

func (*UnimplementedSwapsvcServer) SyncSwapOrder(ctx context.Context, req *SyncSwapOrderRequest) (*SyncSwapOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncSwapOrder not implemented")
}
func (*UnimplementedSwapsvcServer) SwapOrderPage(ctx context.Context, req *SwapOrderPageRequest) (*SwapOrderPageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapOrderPage not implemented")
}
func (*UnimplementedSwapsvcServer) FindSwapOrder(ctx context.Context, req *FindSwapOrderRequest) (*FindSwapOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindSwapOrder not implemented")
}
func (*UnimplementedSwapsvcServer) ListSwapToken(ctx context.Context, req *ListSwapTokenRequest) (*ListSwapTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSwapToken not implemented")
}
func (*UnimplementedSwapsvcServer) GetSwapApproveAllowance(ctx context.Context, req *GetSwapApproveAllowanceRequest) (*GetSwapApproveAllowanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSwapApproveAllowance not implemented")
}
func (*UnimplementedSwapsvcServer) ApproveSwapTransaction(ctx context.Context, req *ApproveSwapTransactionRequest) (*ApproveSwapTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveSwapTransaction not implemented")
}
func (*UnimplementedSwapsvcServer) SwapTrade(ctx context.Context, req *SwapTradeRequest) (*SwapTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapTrade not implemented")
}
func (*UnimplementedSwapsvcServer) SwapQuote(ctx context.Context, req *SwapQuoteRequest) (*SwapQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapQuote not implemented")
}
func (*UnimplementedSwapsvcServer) Test(ctx context.Context, req *TestRequest) (*TestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Test not implemented")
}

func RegisterSwapsvcServer(s *grpc.Server, srv SwapsvcServer) {
	s.RegisterService(&_Swapsvc_serviceDesc, srv)
}

func _Swapsvc_SyncSwapOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncSwapOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).SyncSwapOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/SyncSwapOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).SyncSwapOrder(ctx, req.(*SyncSwapOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_SwapOrderPage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapOrderPageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).SwapOrderPage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/SwapOrderPage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).SwapOrderPage(ctx, req.(*SwapOrderPageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_FindSwapOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindSwapOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).FindSwapOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/FindSwapOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).FindSwapOrder(ctx, req.(*FindSwapOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_ListSwapToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSwapTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).ListSwapToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/ListSwapToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).ListSwapToken(ctx, req.(*ListSwapTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_GetSwapApproveAllowance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSwapApproveAllowanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).GetSwapApproveAllowance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/GetSwapApproveAllowance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).GetSwapApproveAllowance(ctx, req.(*GetSwapApproveAllowanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_ApproveSwapTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApproveSwapTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).ApproveSwapTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/ApproveSwapTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).ApproveSwapTransaction(ctx, req.(*ApproveSwapTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_SwapTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).SwapTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/SwapTrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).SwapTrade(ctx, req.(*SwapTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_SwapQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapQuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).SwapQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/SwapQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).SwapQuote(ctx, req.(*SwapQuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Swapsvc_Test_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapsvcServer).Test(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/swapsvc.Swapsvc/Test",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapsvcServer).Test(ctx, req.(*TestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Swapsvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "swapsvc.Swapsvc",
	HandlerType: (*SwapsvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SyncSwapOrder",
			Handler:    _Swapsvc_SyncSwapOrder_Handler,
		},
		{
			MethodName: "SwapOrderPage",
			Handler:    _Swapsvc_SwapOrderPage_Handler,
		},
		{
			MethodName: "FindSwapOrder",
			Handler:    _Swapsvc_FindSwapOrder_Handler,
		},
		{
			MethodName: "ListSwapToken",
			Handler:    _Swapsvc_ListSwapToken_Handler,
		},
		{
			MethodName: "GetSwapApproveAllowance",
			Handler:    _Swapsvc_GetSwapApproveAllowance_Handler,
		},
		{
			MethodName: "ApproveSwapTransaction",
			Handler:    _Swapsvc_ApproveSwapTransaction_Handler,
		},
		{
			MethodName: "SwapTrade",
			Handler:    _Swapsvc_SwapTrade_Handler,
		},
		{
			MethodName: "SwapQuote",
			Handler:    _Swapsvc_SwapQuote_Handler,
		},
		{
			MethodName: "Test",
			Handler:    _Swapsvc_Test_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "swapsvc.proto",
}

func (m *PageQuick) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageQuick) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Limit))
	}
	if len(m.NextId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.NextId)))
		i += copy(dAtA[i:], m.NextId)
	}
	if m.Total != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalRecords != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.TotalRecords))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.PageSize))
	}
	if m.PageNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.PageNum))
	}
	if m.TotalPage != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.TotalPage))
	}
	return i, nil
}

func (m *TestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	return i, nil
}

func (m *TestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SyncSwapOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncSwapOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SyncSwapOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncSwapOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SwapProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapProvider) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Logo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Logo)))
		i += copy(dAtA[i:], m.Logo)
	}
	return i, nil
}

func (m *Token) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Token) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.Decimals != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Decimals))
	}
	if len(m.LogoUri) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.LogoUri)))
		i += copy(dAtA[i:], m.LogoUri)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Symbol) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Symbol)))
		i += copy(dAtA[i:], m.Symbol)
	}
	if len(m.Price) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Price)))
		i += copy(dAtA[i:], m.Price)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	if len(m.Gas) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Gas)))
		i += copy(dAtA[i:], m.Gas)
	}
	if m.BlockNumber != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.BlockNumber))
	}
	if len(m.GasUsed) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.GasUsed)))
		i += copy(dAtA[i:], m.GasUsed)
	}
	if len(m.GasPrice) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.GasPrice)))
		i += copy(dAtA[i:], m.GasPrice)
	}
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	return i, nil
}

func (m *SwapOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.ChainID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if len(m.DestReceiver) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.DestReceiver)))
		i += copy(dAtA[i:], m.DestReceiver)
	}
	if m.ReceiptStatus != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ReceiptStatus))
	}
	if m.FromToken != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.FromToken.Size()))
		n1, err1 := m.FromToken.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.ToToken != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ToToken.Size()))
		n2, err2 := m.ToToken.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.Provider != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Provider.Size()))
		n3, err3 := m.Provider.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if len(m.ContractAddress) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ContractAddress)))
		i += copy(dAtA[i:], m.ContractAddress)
	}
	if m.BlockAt != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.BlockAt))
	}
	if m.Tx != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Tx.Size()))
		n4, err4 := m.Tx.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if len(m.TransactionFee) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.TransactionFee)))
		i += copy(dAtA[i:], m.TransactionFee)
	}
	if m.NativeToken != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.NativeToken.Size()))
		n5, err5 := m.NativeToken.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *SwapOrderPageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapOrderPageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if m.Paginator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Paginator.Size()))
		n6, err6 := m.Paginator.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}

func (m *SwapOrderPageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapOrderPageResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSwapsvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Paginator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Paginator.Size()))
		n7, err7 := m.Paginator.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}

func (m *FindSwapOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindSwapOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.TxHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.TxHash)))
		i += copy(dAtA[i:], m.TxHash)
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	return i, nil
}

func (m *FindSwapOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindSwapOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Data.Size()))
		n8, err8 := m.Data.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}

func (m *ListSwapTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSwapTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.TokenAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.TokenAddress)))
		i += copy(dAtA[i:], m.TokenAddress)
	}
	return i, nil
}

func (m *ListSwapTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListSwapTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSwapsvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetSwapApproveAllowanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSwapApproveAllowanceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.TokenAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.TokenAddress)))
		i += copy(dAtA[i:], m.TokenAddress)
	}
	if len(m.WalletAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.WalletAddress)))
		i += copy(dAtA[i:], m.WalletAddress)
	}
	if len(m.AggregatorAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.AggregatorAddress)))
		i += copy(dAtA[i:], m.AggregatorAddress)
	}
	return i, nil
}

func (m *GetSwapApproveAllowanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSwapApproveAllowanceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if len(m.Allowance) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Allowance)))
		i += copy(dAtA[i:], m.Allowance)
	}
	return i, nil
}

func (m *ApproveSwapTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApproveSwapTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.TokenAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.TokenAddress)))
		i += copy(dAtA[i:], m.TokenAddress)
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if len(m.AggregatorAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.AggregatorAddress)))
		i += copy(dAtA[i:], m.AggregatorAddress)
	}
	return i, nil
}

func (m *ApproveSwapTransactionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApproveSwapTransactionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if len(m.GasPrice) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.GasPrice)))
		i += copy(dAtA[i:], m.GasPrice)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *SwapQuoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapQuoteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if len(m.FromTokenAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAddress)))
		i += copy(dAtA[i:], m.FromTokenAddress)
	}
	if len(m.ToTokenAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAddress)))
		i += copy(dAtA[i:], m.ToTokenAddress)
	}
	return i, nil
}

func (m *SwapQuoteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapQuoteInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fee != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fee))))
		i += 4
	}
	if len(m.EstimateGasFee) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.EstimateGasFee)))
		i += copy(dAtA[i:], m.EstimateGasFee)
	}
	if m.Aggregator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Aggregator.Size()))
		n9, err9 := m.Aggregator.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if len(m.FromTokenAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAddress)))
		i += copy(dAtA[i:], m.FromTokenAddress)
	}
	if len(m.ToTokenAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAddress)))
		i += copy(dAtA[i:], m.ToTokenAddress)
	}
	if len(m.FromTokenAmount) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAmount)))
		i += copy(dAtA[i:], m.FromTokenAmount)
	}
	if len(m.ToTokenAmount) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAmount)))
		i += copy(dAtA[i:], m.ToTokenAmount)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.FetchTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.FetchTime))
	}
	return i, nil
}

func (m *SwapQuoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapQuoteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSwapsvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SwapTradesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapTradesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if len(m.FromTokenAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAddress)))
		i += copy(dAtA[i:], m.FromTokenAddress)
	}
	if len(m.ToTokenAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAddress)))
		i += copy(dAtA[i:], m.ToTokenAddress)
	}
	if m.Slippage != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Slippage))))
		i += 4
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if len(m.DestReceiver) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.DestReceiver)))
		i += copy(dAtA[i:], m.DestReceiver)
	}
	if len(m.AggregatorAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.AggregatorAddress)))
		i += copy(dAtA[i:], m.AggregatorAddress)
	}
	return i, nil
}

func (m *SwapTradeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapTradeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.ChainID))
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if len(m.FromTokenAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAddress)))
		i += copy(dAtA[i:], m.FromTokenAddress)
	}
	if len(m.ToTokenAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAddress)))
		i += copy(dAtA[i:], m.ToTokenAddress)
	}
	if m.Slippage != 0 {
		dAtA[i] = 0x2d
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Slippage))))
		i += 4
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if len(m.DestReceiver) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.DestReceiver)))
		i += copy(dAtA[i:], m.DestReceiver)
	}
	if len(m.AggregatorAddress) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.AggregatorAddress)))
		i += copy(dAtA[i:], m.AggregatorAddress)
	}
	return i, nil
}

func (m *SwapTradeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapTradeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Code))))
		i += 4
	}
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Data.Size()))
		n10, err10 := m.Data.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}

func (m *SwapTradeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapTradeInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fee != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Fee))))
		i += 4
	}
	if m.Trade != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Trade.Size()))
		n11, err11 := m.Trade.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	if m.Aggregator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Aggregator.Size()))
		n12, err12 := m.Aggregator.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	if len(m.FromTokenAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAddress)))
		i += copy(dAtA[i:], m.FromTokenAddress)
	}
	if len(m.ToTokenAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAddress)))
		i += copy(dAtA[i:], m.ToTokenAddress)
	}
	if len(m.FromTokenAmount) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.FromTokenAmount)))
		i += copy(dAtA[i:], m.FromTokenAmount)
	}
	if len(m.ToTokenAmount) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ToTokenAmount)))
		i += copy(dAtA[i:], m.ToTokenAmount)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.FetchTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.FetchTime))
	}
	return i, nil
}

func (m *SwapTradesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapTradesResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintSwapsvc(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Trade) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trade) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.From) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if len(m.GasPrice) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.GasPrice)))
		i += copy(dAtA[i:], m.GasPrice)
	}
	if len(m.GasLimit) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.GasLimit)))
		i += copy(dAtA[i:], m.GasLimit)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *Aggregator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.ContractAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.ContractAddress)))
		i += copy(dAtA[i:], m.ContractAddress)
	}
	if len(m.Logo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSwapsvc(dAtA, i, uint64(len(m.Logo)))
		i += copy(dAtA[i:], m.Logo)
	}
	return i, nil
}

func encodeVarintSwapsvc(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *PageQuick) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Limit != 0 {
		n += 1 + sovSwapsvc(uint64(m.Limit))
	}
	l = len(m.NextId)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovSwapsvc(uint64(m.Total))
	}
	return n
}

func (m *Page) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalRecords != 0 {
		n += 1 + sovSwapsvc(uint64(m.TotalRecords))
	}
	if m.PageSize != 0 {
		n += 1 + sovSwapsvc(uint64(m.PageSize))
	}
	if m.PageNum != 0 {
		n += 1 + sovSwapsvc(uint64(m.PageNum))
	}
	if m.TotalPage != 0 {
		n += 1 + sovSwapsvc(uint64(m.TotalPage))
	}
	return n
}

func (m *TestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *TestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	return n
}

func (m *SyncSwapOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SyncSwapOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	return n
}

func (m *SwapProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *Token) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovSwapsvc(uint64(m.Decimals))
	}
	l = len(m.LogoUri)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Price)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Gas)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovSwapsvc(uint64(m.BlockNumber))
	}
	l = len(m.GasUsed)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.DestReceiver)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.ReceiptStatus != 0 {
		n += 1 + sovSwapsvc(uint64(m.ReceiptStatus))
	}
	if m.FromToken != nil {
		l = m.FromToken.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.ToToken != nil {
		l = m.ToToken.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Provider != nil {
		l = m.Provider.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.BlockAt != 0 {
		n += 1 + sovSwapsvc(uint64(m.BlockAt))
	}
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.TransactionFee)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.NativeToken != nil {
		l = m.NativeToken.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapOrderPageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Paginator != nil {
		l = m.Paginator.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapOrderPageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovSwapsvc(uint64(l))
		}
	}
	if m.Paginator != nil {
		l = m.Paginator.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *FindSwapOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *FindSwapOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *ListSwapTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.TokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *ListSwapTokenResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovSwapsvc(uint64(l))
		}
	}
	return n
}

func (m *GetSwapApproveAllowanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.TokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.WalletAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.AggregatorAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *GetSwapApproveAllowanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	l = len(m.Allowance)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *ApproveSwapTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.TokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.AggregatorAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *ApproveSwapTransactionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapQuoteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapQuoteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != 0 {
		n += 5
	}
	l = len(m.EstimateGasFee)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Aggregator != nil {
		l = m.Aggregator.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAmount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAmount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.FetchTime != 0 {
		n += 1 + sovSwapsvc(uint64(m.FetchTime))
	}
	return n
}

func (m *SwapQuoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovSwapsvc(uint64(l))
		}
	}
	return n
}

func (m *SwapTradesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Slippage != 0 {
		n += 5
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.DestReceiver)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.AggregatorAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapTradeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainID != 0 {
		n += 1 + sovSwapsvc(uint64(m.ChainID))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Slippage != 0 {
		n += 5
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.DestReceiver)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.AggregatorAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapTradeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 5
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *SwapTradeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fee != 0 {
		n += 5
	}
	if m.Trade != nil {
		l = m.Trade.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.Aggregator != nil {
		l = m.Aggregator.Size()
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.FromTokenAmount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ToTokenAmount)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	if m.FetchTime != 0 {
		n += 1 + sovSwapsvc(uint64(m.FetchTime))
	}
	return n
}

func (m *SwapTradesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovSwapsvc(uint64(m.Code))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovSwapsvc(uint64(l))
		}
	}
	return n
}

func (m *Trade) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.GasPrice)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.GasLimit)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func (m *Aggregator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.ContractAddress)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovSwapsvc(uint64(l))
	}
	return n
}

func sovSwapsvc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSwapsvc(x uint64) (n int) {
	return sovSwapsvc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PageQuick) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageQuick: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageQuick: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNum", wireType)
			}
			m.PageNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPage", wireType)
			}
			m.TotalPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncSwapOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncSwapOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncSwapOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncSwapOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncSwapOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncSwapOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Token) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Token: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Token: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogoUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Price = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gas = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasUsed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestReceiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestReceiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiptStatus", wireType)
			}
			m.ReceiptStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiptStatus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FromToken == nil {
				m.FromToken = &Token{}
			}
			if err := m.FromToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ToToken == nil {
				m.ToToken = &Token{}
			}
			if err := m.ToToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Provider == nil {
				m.Provider = &SwapProvider{}
			}
			if err := m.Provider.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockAt", wireType)
			}
			m.BlockAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tx == nil {
				m.Tx = &Transaction{}
			}
			if err := m.Tx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NativeToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NativeToken == nil {
				m.NativeToken = &Token{}
			}
			if err := m.NativeToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapOrderPageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapOrderPageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapOrderPageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paginator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Paginator == nil {
				m.Paginator = &Page{}
			}
			if err := m.Paginator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapOrderPageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapOrderPageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapOrderPageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SwapOrder{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paginator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Paginator == nil {
				m.Paginator = &Page{}
			}
			if err := m.Paginator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindSwapOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindSwapOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindSwapOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindSwapOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindSwapOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindSwapOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &SwapOrder{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSwapTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSwapTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSwapTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListSwapTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListSwapTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListSwapTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Token{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSwapApproveAllowanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSwapApproveAllowanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSwapApproveAllowanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSwapApproveAllowanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSwapApproveAllowanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSwapApproveAllowanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allowance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApproveSwapTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApproveSwapTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApproveSwapTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApproveSwapTransactionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApproveSwapTransactionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApproveSwapTransactionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapQuoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapQuoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapQuoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapQuoteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapQuoteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapQuoteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Fee = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EstimateGasFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EstimateGasFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregator == nil {
				m.Aggregator = &Aggregator{}
			}
			if err := m.Aggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchTime", wireType)
			}
			m.FetchTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapQuoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapQuoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapQuoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SwapQuoteInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapTradesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapTradesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapTradesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slippage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Slippage = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestReceiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestReceiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapTradeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapTradeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapTradeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			m.ChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slippage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Slippage = float32(math.Float32frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestReceiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestReceiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapTradeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapTradeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapTradeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Code = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &SwapTradeInfo{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapTradeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapTradeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapTradeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Fee = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trade", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trade == nil {
				m.Trade = &Trade{}
			}
			if err := m.Trade.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Aggregator == nil {
				m.Aggregator = &Aggregator{}
			}
			if err := m.Aggregator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromTokenAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchTime", wireType)
			}
			m.FetchTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FetchTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapTradesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapTradesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapTradesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SwapTradeInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trade) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trade: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trade: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GasLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSwapsvc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSwapsvc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSwapsvc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSwapsvc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSwapsvc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSwapsvc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSwapsvc
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthSwapsvc
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSwapsvc
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSwapsvc(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthSwapsvc
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSwapsvc = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSwapsvc   = fmt.Errorf("proto: integer overflow")
)
